## 创建高性能的索引

### 5.1 索引基础

#### 5.1.1 索引的类型

MYSQL支持的索引：
##### B-Tree索引
InnoDB使用的是B+Tree实现的这种索引。

B-Tree意味着所有的值都是按顺序存储的，并且每一个叶子到根的距离都相同。

InnoDB中的B-Tree索引的抽象表示如下：
![avatar](/assets/images/mysql_InnoDB_BTree结构.png)

根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点的值和目标值，找到合适的指针进入下层节点。

叶子节点的指针指向被索引的数据，而不是其他的节点。

BTree对索引列是顺序组织存储的，所以适合查找范围数据

可以使用B-Tree索引的查询类型：
+ 全值匹配
+ 匹配最左前缀
+ 匹配列前缀
+ 匹配范围值
+ 精确匹配某一列并范围匹配另一列
+ 只访问索引的查询

一些关于B-Tree索引的限制：
+ 如果不是按照索引的最左列开始查找，则无法使用索引
+ 不能跳过索引中的列
+ 如果查询中有某个列的范围查询，则其邮编所有列都无法使用索引优化查找

##### Hash索引
基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎会对所有的索引列计算一个哈希值，
哈希索引将所有的哈希值存储在索引中，同时在哈希表中保存指向每个数据行的指针

略

##### 空间数据索引
略

##### 全文索引
略

### 5.2 索引的优点
1. 减少服务器需要扫描的数据量
2. 帮助服务器避免排序和临时表
3. 将随机IO变为顺序IO

### 5.3 高性能的索引策略

#### 5.3.1 独立的列
养成优化WHERE条件的习惯，始终将索引列单独放在比较符号的一侧

#### 5.3.2 前缀索引和索引选择性
索引的选择性：不重复的索引值和数据表的记录的总数的比值。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MYSQL在查询时过滤掉更多的行。
唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

对于BLOB、TEXT或者VARCHAR的列，必须使用前缀索引，否则MYSQL不允许索引这些列的完整长度。
诀窍在于选择足够长的前缀以保证高的选择性，同时也不能太长以便节约空间。

创建前缀索引：
```
ALTER TABLE tbl_name ADD KEY (col_name(prefix_length))
```
前缀索引的缺点：MySQL无法使用前缀索引进行ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描

#### 5.3.3 多列索引
MySQL5.0以上版本能够使用多个单列索引进行扫描，并将结果进行合并。但是这也说明了表的索引建的很糟糕：
+ 当出现服务器对多个索引做相交操作时（通常有多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引
+ 当服务器需要对多个索引做联合操作时（通常有多个OR条件），通常需要耗费大量的CPU核内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的索引选择性不搞，返回了大量的数据
+ 优化器只关心随机页面读取，所以上面的这些成本不会被优化器计算到查询成本中，导致该执行计划还不如扫描全表，不仅耗费更多的CPU和内存，也会影响查询的并发性。

#### 5.3.4 选择合适的索引列顺序
对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引的最前列。这个建议在某些场景下游一定帮助。但是通常不如避免随机IO和排序重要。

也就是说：
当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这时候索引只用于优化WHERE条件的查找。


#### 5.3.5 聚簇索引
聚簇索引是一种数据存储方式。具体的细节依赖于其实现方式。InnoDB的聚簇索引实际上在同一个结构中保存了BTree索引和数据行。

当表有聚簇索引时，它的数据行实际上存放在索引的叶子中，"聚簇"表示数据行和相邻的键值紧凑的存储在一起。
因为无法同时把数据行存放在2个不同的地方，所以一个表只能有一个聚簇索引。（PS：覆盖索引可以模拟多个聚簇索引的情况）

聚簇索引中记录存放如下：
![avatar](/assets/images/mysql_聚簇索引的数据分布.png)

叶子包含了行的全部数据，但是节点值包含了索引列。

InnoDB通过将**主键**聚集数据，也就是说，上图中的被索引的列就是"主键列"

如果没有定义主键，InnoDB会选择一个唯一的的非空索引代替，如果还没有，InnoDB会隐式的定义一个主键来作为聚簇索引。

聚集的数据有一些优点：
+ 可以把相关数据保存在一起，例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，可能每封邮件都需要一次IO
+ 数据访问更快，聚簇索引将索引和数据保存在同一个BTree中，因此查找更快
+ 使用覆盖索引扫描的查询可以直接使用叶节点中的主键值

聚簇索引的一些缺点：
+ 聚簇数据最大限度的提高了IO密集型应用的性能，但是如果数据全部都在内存中，访问顺序就不重要了。聚簇索引也就没什么优势
+ 插入速度严重依赖于插入顺序，按照主键的顺序插入数据是最快的，如果不是，那么尽量在加载完成后使用OPTIMIZE TABLE来重新组织一下表
+ 更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置
+ 基于聚簇索引的表在插入新行，或者主键被更新导致行的移动时，可能面临"页分裂"的问题。当行的主键值要求必须要将这一行插入某个已满的页中时，存储引擎会将改页分裂成两个页来容纳该行。
这就是一次页分裂操作，会导致表占用更多的磁盘空间。
+ 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候
+ 二级索引可能比想象中要更大，因为二级索引的叶子节点包含了引用行的主键列
+ 二级索引访问需要两次索引查找，即二级索引中的行指针指向的是行的主键值，而不是行的物理位置。在InnoDB中，自适应哈希索引能够减少这样的重复操作

InnoDB和MyISAM的数据分布对比
+ MyISAM按照数据插入的顺序存储在磁盘。
+ InnoDB因为支持聚簇索引，所以使用了和MyISAM非常不同的存储方式
在InnoDB中，聚簇索引就是表，不需要独立的行存储。

在InnoDB中按照主键顺序插入行
如果正在使用InnoDB且没有什么数据需要聚集，可以定义一个代理键作为主键（最简单的是使用AUTO_INCREMENT自增列），这样保证数据行按照顺序写入，对于根据主键做关联操作的性能也会更好

最好避免随机的聚簇索引。否则InnoDB在插入数据时，总是无法简单的将新行插入到索引的最后，而是需要为新的行寻找合适的位置，并且分配空间
+ 写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘将目标页读取到内存，这导致了大量的随机IO
+ 因为写入是乱序的，InnoDB不得不频繁的做"页分裂"操作，以便为新的行分配空间，页分裂会移动大量数据
+ 由于频繁的页分裂，也变得稀疏，有数据碎片

#### 5.3.6 覆盖索引
如果一个索引包含（覆盖）所有需要查询的字段，那么就称为"索引覆盖"。

索引覆盖可以极大的提高性能
+ 索引条目通常小于数据行大小，所以只需要读取索引，那么MySQL就会极大的减少数据访问量
+ 因为索引是按照列值顺序存储的，所以对于IO密集型的范围查询会比随机从磁盘读取每一行的IO要少得多。
+ 对于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用，InnoDB的二级索引在叶子节点中保存了行的主键值，如果二级主键能够覆盖查询，那么就可以避免对主键索引的二次查询

不是所有类型的索引都可以成为覆盖索引，覆盖索引必须要存储索引列的值，所以MySQL只能使用BTree索引做覆盖索引。
当发起一个被索引覆盖的查询，EXPLAIN的Extra中可以看到`Using index`的信息。

索引覆盖查询还有很多陷阱导致无法实现优化，MySQL查询优化器会在执行查询前判断是否有一个索引可以覆盖，假设索引覆盖了WHERE条件中的字段，但不是整个查询涉及的字段。
那么此时，MySQL5.5或者更早版本也总是会回表获取数据行。

在InnoDB中，二级索引的叶子节点包含了主键的值，因此意味着InnoDB的二级索引可以有效的利用这些"额外"的主键来覆盖查询


#### 5.3.7 使用索引扫描来排序
MySQL有2种方式可以生成有序的结果：
+ 排序操作
+ 按索引顺序扫描，EXPLAIN出来的type列的值为"index", 说明MySQL使用了索引扫描来做排序

扫描索引本身是很快的，但是如果索引不能覆盖查询所需要的全部列，那么就不得不扫描一条索引记录就回表查询一次对应的行，这基本都是随机IO，
因此按索引顺序读取数据的速度通常比顺序的扫描全表要慢。

MySQL可以使用同一个索引既满足排序，又用于查找行，如果可能，尽量同时满足。

只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且排列方向都一样时，MySQL才能够使用索引来对结果做排序。
如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。

ORDER BY子句和查找型查询的限制是一样的，需要满足索引的最左前缀匹配要求，否则，MySQL都要执行排序操作，无法利用索引排序。
但是有一种情况除外，前导列为常量时，即WHERE子句或者JOIN子句对这些列指定了常量，就可以"弥补"索引的不足


#### 5.3.8 压缩（前缀压缩）索引
略

#### 5.3.9 冗余和重复索引
冗余索引一定场景下可以增加效率，但是索引越多，插入、更新、删除操作的速度都沪变慢。

如果有一个列索引（A），其实相当于在（A，ID）上的索引，如果将索引扩展为（A，B），那么实际上变成了(A, B, ID)

#### 5.3.10 未使用的索引
删除未使用的索引

#### 5.3.11 索引和锁
索引可以让查询锁定更少的行。虽然InnoDB的行锁效率很高，内存使用也很少，但是锁定行的时候仍然会带来额外开销，其次，锁定超过需要的行会增加锁争用并减少并发性

**InnoDB在二级索引上使用共享(读)锁，但是访问主键索引需要排他(写)锁，这消除了使用覆盖索引的可能，并且使得`SELECT FOR UPDATE`比`LOCK IN SHARE MODE`或非锁定查询要慢很多**

**对于范围条件查询，M有SQL无法再使用范围列后面其他的索引列了，所以首先尽量将范围查询放到索引的最后面，但是对于"多个等值条件查询"(比如IN)就没有这个限制**


### 5.5 维护索引和表

#### 5.5.1 找到并修复损坏的表
重建表：
```
ALTER TABLE innodb_tbl ENGINE=INNODB;
```
如果InnoDB的表出现了损坏，那么一定是发生了严重错误，一般要么是数据库硬件问题，要么是由于DBA的错误的在MySQL外部操作了数据文件。
常见的类似错误通常是由于尝试使用`rsync`备份InnoDB导致的，可以通过设置`innodb_force_recovery`进行InnoDB的强制恢复模式来修复数据，还可以使用开源的InnoDB数据恢复工具箱来恢复文件数据

#### 5.5.2 更新索引统计信息
MySQL查询优化器会通过两个API来了解存储引擎的索引值的分布信息，以决定如何使用索引。
1. records_in_range(): 在InnoDB下，会返回两个边界中记录的估计值
2. info(), 返回各种类型的数据，包括索引的基数(每个键值有多少条记录)

当存储引擎向优化器提供的扫描行数信息不准确，或者执行计划过于复杂，那么优化器会使用索引统计信息来估算扫描行数。
MySQL优化器使用的是基于成本的模型，衡量成本的主要指标就是一个查询需要扫描多少行。如果表没有统计信息，或者统计信息不准确，优化器就有可能做出错误的决定。

InnoDB的统计信息值得深入研究。
InnoDB通过抽样的方式来计算统计信息：
+ 首先，随机的读取少量的索引页面
+ 然后以此为样本计算索引的统计信息
+ 可以通过设置`innodb_stats_sample_pages`来指定样本页的数量

InnoDB会在**首次打开、或者执行ANALYZE TABLE、或者表的大小发生非常大的变化(大小变化超过1/16或者新插入了20亿行)时候**， 会计算索引的统计信息。

InnoDB在打开某些INFORMATION_SCHEMA表、或者使用SHOW TABLE STATUS和SHOW INDEX、或者在MYSQL客户端开启自动补全功能时，会触发索引统计信息的更新，
这在服务器有大量数据时，会引发严重的性能问题，采样更新会导致大量的锁。可以关闭`innodb_stats_on_metadata`来避免。

#### 5.5.3 减少索引和数据的碎片
B-Tree索引可能会碎片化，降低查询效率，碎片化的索引可能会以很差或者无序的方式存储在磁盘上。

根据设计，B-Tree需要随机访问磁盘才能定位到叶子页，所以随机访问不可避免，然而，如果叶子页在物理分布上是顺序且紧密的，那么查询的效率就很好。
否则，对于范围查询、索引覆盖扫描等操作来说，速度会降低很多。

表的数据存储也可以碎片化，比索引碎片更加复杂，有3种类型的数据碎片：
1. 行碎片：指的是数据行被存储为多个地方的多个片段中。
2. 行间碎片：指逻辑上顺序的页/行在磁盘上不是顺序存储的
3. 剩余空间碎片：指数据页中有大量的空余空间

InnoDB不会出现短小的行碎片，InnoDB会移动短小的行，然后重新写到一个片段中。

使用`OPTIMIZE TABLE`或者导出再导入的方法来重新整理数据，这对多数存储引擎都是有效的。


### 5.6 总结
在选择索引和编写利用这些索引的查询时，记住以下3个原则：
1. 单行访问时很慢的，特别是在机械硬盘存储中。如果服务器从存储中读取一个数据块仅仅是为了获取其中一行，那么就浪费了很多工作。
最好读取的块中包含尽可能多所需要的行。使用索引可以创建位置引用以提升效率
2. 按顺序访问范围数据是很快的。原因之一是顺序IO不需要过多的磁盘寻道，比随机IO要快很多；原因之二是如果服务器能够按照需要的顺序读取数据，就不需要再额外的排序
3. 索引覆盖查询时很快的。不需要回表查找行，避免了大量的单行访问



