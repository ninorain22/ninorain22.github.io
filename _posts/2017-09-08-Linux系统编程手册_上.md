---
layout: post
title: Linux系统编程手册 上
tags:
- PHP
- 内存
date: 2017-09-08 12:00:00.000000000 +09:00
---

# 第1章 历史和标准
略

# 第2章 基本概念
## 2.7 进程

### 进程的内存布局
逻辑上将一个进程划分为以下几部分(也称为段)：
+ 文本： 程序的指令
+ 数据：程序使用的静态变量
+ 堆：程序可从该区域动态分配的额外内存
+ 栈：随函数调用、返回而增减的一片内存，用于为局部变量和函数调用链接信息而分配的存储空间


## 2.8 内存映射

调用系统函数mmap()的进程，会在其虚拟地址空间创建一个新的内存映射
+ 文件映射：将文件的部分区域映射入调用进程的虚拟内存
+ 匿名映射：其映射页面的内容会被初始化为0


## 2.10 进程间通信及同步

+ 信号，用来表示事件的发生
+ 管道和FIFO，用于在进程间传递数据
+ 套接字，供一台主机或者不同主机上所运行的进程之间传递数据
+ 文件锁定，防止其他进程读取或更新文件内容，允许某些进程对文件部分区域加以锁定’
+ 消息队列，用于在进程间交换信息
+ 信号量，用于同步进程动作
+ 共享内存，允许2个或者多个进程共享一块内存。当某进程改变了共享内存的内容时，其他所有进程会立即了解这一变化


# 第3章 系统编程概念

## 3.1 系统调用

+ 系统调用将处理器从用户态切换到核心态，以便CPU访问受到保护的内核内存
+ 系统调用的组成是固定的，每个系统调用都由一个唯一的数字来标识
+ 每个系统调用可辅之一套参数，对用户空间和内核空间传递的消息加以规范

以X86-32为例，系统调用的步骤：
1. 应用程序通过调用C语言函数库中的外壳函数，发起系统调用
2. 对系统调用中断处理程序来说，外壳函数必须保证所有的系统调用参数可用。通过堆栈，这些参数传入外壳函数，外壳函数将这些参数复制到寄存器
3. 外壳函数将系统调用号复制到一个特殊的CPU寄存器（EAX）中，来使内核可用区分每个系统调用
4. 外壳函数执行一条中断机器指令(int 0x80)，引发处理器从用户态切换到核心态，并执行系统中断0x80中的中断矢量所指向的代码
5. 为响应中断0x80，内核会调用system_call()例程来处理中断，具体步骤如下：
    1. 在内核栈中保存寄存器值
    2. 审核系统调用号的有效性
    3. 发现并调用相应的系统调用服务例程。可能涉及对特定参数中的指定地址处的值进行修改，以及在用户内存和内核内存之间传递数据，最后，会将结果状态返回给system_call()
    4. 从内核栈中恢复各寄存器值，并将系统调用返回值置于栈中
    5. 返回外壳函数，同时将处理器切换回用户态
6. 若结果返回有错误，外壳函数会将返回值来设置全局变量errno，然后返回到调用程序，并同时返回一个整型值，以表明系统调用是否成功


# 第4章 文件I／O：通用的I／O模型

## 4.1 概述

所有执行IO操作的系统调用都以文件描述符，一个非负整数，来指代打开的文件。用以表示所有类型的已打开文件，包括管道、FIFO、socket、终端、设备和普通文件。

shell代表程序打开3个文件描述符：
+ 0    标准输入    stdin
+ 1    标准输出    stdout
+ 2    标准错误    stderr

文件IO的4个主要系统调用
+ fd = open(pathname, flags, mode)
+ numread = read(fd, buffer, count)
+ numwritten = write(fd, buffer, count)
+ status = close(fd)


## 4.3 打开一个文件：open()
int open(const char *pathname, int flags, … /* mode_t mode */);


## 4.4 读取文件内容：read()
ssize_t read(int fd, void *buffer, size_t count);

必须预先分配大小合适的缓冲区并将缓冲区指针传递给系统调用，因为read系统调用不会分配内存缓冲区。
因为read()无法区分读取的信息，因此在读出的字符串尾部追加字符串结束苻是必要的
char buffer[MAX_READ + 1];
ssize_t numRead;

numRead = read(STDIN_FILENO, buffer, MAX_READ);
if (numRead == -1)
    errExit(“read”);

buffer[numRead] = ‘\0’;
printf("%s\n”, buffer);



## 4.5 数据写入文件：write()
ssize_t(int fd, void *buffer, size_t count);

如果write()调用成功，将返回实际写入文件的字节数，该返回值可能会小于count值，称为*部分写*，原因可能是磁盘已满，或者是进程资源对文件大小的限制。
对磁盘文件进行IO时，write()调用成功并不能保证数据已经写入磁盘，因为内核会缓存磁盘的IO操作


## 4.6 关闭文件：close()
int close(int fd);


## 4.7 改变文件偏移量：lseek()
off_t lseek(int fd, off_t offset, int whence);

// 获取文件偏移量的当前位置
curr = lseek(fd, 0, SEEK_CUR);

lseek()调用只是调整内核中与文件描述符相关的文件偏移量记录字段，并没有任何物理设备的访问。
不允许将lseek()应用于管道、FIFO、socket或终端。

#### 文件空洞
当文件的偏移量已经跨越了文件结尾，再执行IO操作，从文件结尾后到新写入数据间的这段空间被称为*文件空洞*。读取文件空洞，将返回以0填充的缓冲区。
文件空洞在当其被写入了数据，文件系统才会为之分配磁盘块。


## 4.8 通用IO模型以外的操作：ioctl()
int ioctl(int fd, int request, …/* argp */);


# 第5章 深入探究文件IO

## 5.1 原子操作和竞争条件
+ 结合O_CREATE和O_EXCL标志来一次性调用open()可以确保以独占的方式来创建文件
+ 加入O_APPEND标志保证原子的向文件尾部追加数据


## 5.2 文件操作控制：fcntl()
int fcntl(int fd, int cmd, ...);


## 5.3 打开文件的状态标志
fcntl()用途之一说针对一个打开的文件，获取或修改其访问模式和状态标志。
int flags, accessMode;

flags = fcntl(fd, F_GETFL);
if (flags == -1)
    errExit(“fcntl”);

// 测试文件是否以同步写方式打开
if (flags & O_SYNC)
    printf(“writes are synchronized\n”);

// 测试文件是否是写模式
accessMode = flags & O_ACCMODE;
if (accessMode == O_WRONLY || accessMode == O_RDWR)
    printf(“file is writable\n”);

可以使用fcntl()的F_SETFL命令来修改打开文件的某些状态标志。允许更改的标志有O_APPEND、O_NONBLOCK、O_NOATIME、O_ASYNC和O_DIRECT。使用fcntl()修改文件状态标志，尤其适用于如下场景：
+ 文件不是由调用程序打开的，所以程序也无法使用open()调用来控制文件的状态标志
+ 文件描述符的获取是通过open()之外的系统调用，比如pipe()调用，该调用创建一个管道，并返回两个文件描述符分别对应管道的两端。再比如socket()调用创建一个套接字并返回指向该套接字的文件描述符

int flags;

flags = fcntl(fd, F_GETFL);
if (flags == -1)
    errExit(“fcntl”);
flags |= O_APPEND;
if (fcntl(fd, F_SETFL, flags) == -1)
    errExit(“fcntl”);


## 5.4 文件描述符和打开文件之间的关系
+ 进程级的文件描述符表
+ 系统级的打开文件表
+ 文件系统的i-node表

针对每个进程，内核为其维护了打开文件的描述符表，每一条目都记录了单个文件描述符的信息
+ 空间文件描述符操作的一组标志
+ 对打开文件句柄的引用

内核对所有打开的文件维护一个系统级的描述表格，打开文件表。表中各条目称为打开文件句柄
+ 当前文件偏移量
+ 打开文件时所使用的标志状态（即open()的flags参数）
+ 文件访问模式
+ 与信号驱动IO相关的设置
+ 对该文件i-node对象的引用

每个文件系统都会为驻留其上的所有文件建立一个i-node表。
+ 文件类型和访问权限
+ 指向该文件所持有的锁的列表的指针
+ 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳

+ 两个不同的文件描述符，若指向同一打开文件句柄，那么将共享同一文件偏移量
+ 要获取和修改打开的文件标志，可执行fcntl()的F_GETFL和F_SETFL操作
+ 文件描述符标志为进程和文件描述符所私有，对这一标志的修改将不回影响同一进程中其他文件描述符


## 5.5 复制文件描述符
IO重定向语法``2>&1``，可以通知shell把标准错误重定向到标准输出
$ ./myscript > result.log 2>&1

dup()调用复制一个打开的文件描述符oldfd，并返回一个新描述符，二者都指向同一打开的文件句柄。
int dup(int oldfd);

newfd = dup(1);
// 在正常情况下，shell以及代表程序打开了文件描述符0、1和2，且没有其他描述符在用，dup(1)返回的文件描述符符号值为3
// 如果希望返回文件描述符2，可以如下：
close(2);
newfd = dup(1);
// 或者
newfd = dup2(1, 2);
// 或者使用fcntl()
newfd = fcntl(oldfd, F_DUPFD, startfd);  // 使用大于等于startfd的最小未使用作为描述符编号

文件描述符的正、副本之间共享同一打开文件句柄所含的文件偏移量和状态标志。然而，新文件描述符有其自己的一套文件描述符标志
// 可以直接控制新文件描述符的close-on-exec标志,且目前仅支持一个标志O_CLOEXEC
int dup3(int oldfd, int newfd, int flags);
 

## 5.6 在文件特定偏移量处的IO：pread()和pwrite()
ssize_t pread(int fd, void *buf, size_t count, off_t offset);
ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);

进程下的所有线程将共享同一文件描述符表，这也意味着每个已打开文件的文件偏移量被所有线程共享。


## 5.7 分散输入和集中输出：readv()和writev()

