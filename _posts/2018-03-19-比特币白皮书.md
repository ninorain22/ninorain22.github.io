---
layout: post
title: 比特币白皮书
date: 2018-03-19 16:30:00.000000000 +09:00
---

## 1. 简介
基于密码学原理而不基于传统贸易中的信用，是的任何达成一致的双方，能够直接进行支付，从而不需要第三方中介的参与。杜绝回滚支付交易的可能，这样就可以保护特定的卖家免于欺诈；对于想要保护买家的人来说，在此环境上设立通常的第三方担保机制也很简单。
比特币是一种通过点对点分布的时间戳服务器来生成依照时间前后排列并加以记录的电子交易证明，从而解决双重支付问题。


## 2. 交易(Transaction)
我们这样定义，一枚电子货币是这样一串数字签名：
每一位所有者通过对前一次交易和下一位拥有者的公钥(Public key)签署一个随机散列的数字签名，并将这个签名附加在这枚电子货币的末尾，电子货币就发送给了下一位所有者。而收款人通过对签名进行校验，就能够验证该链条的所有者。

该过程的问题在于：收款人难以校验，之前的某位所有者，是否对这枚电子货币进行了双重支付。通常的解决方案，就是引入信得过的第三方权威，或者类似造币厂(mint)的机构，来对每一笔交易进行检验，防止双重支付。

但是这样整个货币系统就完全依赖于这些造币厂。因此，我们需要收款人有某种方法，能够确保之前的所有者没有对更早发生的交易实施签名。

从逻辑上看，为了达到目的，实际上需要关注的只是本交易之前发生的交易。为了确保某一次交易是不存在的，唯一的方法就是获悉之前发生过的所有交易。

如果想在电子系统中排除第三方机构，那么交易信息就应当被公开宣布(publicly announced)。我们需要整个系统内的所有参与者，都有唯一公认的历史交易序列，收款人需要确保在交易期间大多数的节点都认同该交易是首次出现


## 3. 时间戳服务器(Timestamp server)
时间戳服务器通过对区块(block)形式存在的一组数据实施随机散列而加上时间戳，并将该随机散列进行广播。显然，该时间戳能够证实特定数据必然于某特定时间是的确存在的，因为只有在该时刻存在才能获取相应的随机散列值。每个时间戳应当将前一个时间戳纳入到随机散列值中，进行增强(reinforcing)，这样就形成了一个链条(chain)


## 4. 工作量证明(Proof-of-Work)
在进行随机散列运算时，工作量证明机制引入了对某一个特定址的扫描工作，比方说SHA-256下，随机散列值以一个或多个0开始，那么随着0的数量的上升，找到这个解决所需要的工作量指数增长，而多结果进行检验则仅需要一次随机散列运算

我们在区块中补增一个随机数(Nonce)，这股随机数要是的该给定区块的随机散列值出现了所需的那么多个0。我们通过反复尝试来找到这股随机数，知道找到为止，这样就构建了一个工作量证明机制。


## 5. 网络
运行该网络的步骤如下：
1. 新的交易向全网进行广播;
2. 每个节点豆浆收到的交易信息纳入一个区块中;
3. 每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明;
4. 当一个节点找到了一个工作量证明，它就向全网进行广播;
5. 当且仅当包含在该区块中的所有交易都是有效的且之前未存在过的，其他节点才认同该区块的有效性;
6. 其他节点表示他们接受该区块，而表示接受的方法，则是在跟随该区块的末尾，制造新的区块以延长该链条，而将被接受区块的随机散列值实为先于新区块的随机散列值

节点始终都将最长的链条实为正确的链条，并持续工作和延长它。如果有两个节点同时广播不同版本的区块，那么其他节点在收到该区块的时间上存在先后差别。此时，他们将在率先收到的区块基础上进行工作，但也会保留另外一个链条，以防止其成为更长的链条。

该僵局(tie)的打破要等到下一个工作量证明被发现，而其中的一条链条被证实为是更长的一条，那么在另一条分之链条上工作的节点将会转换阵营，开始在较长的链条上工作


## 6. 激励
我们如此约定：每个区块的第一笔交易进行特殊化处理，该交易产生一枚由该区块制造者拥有的新的电子货币。这样就增加了节点支持该网络的激励，并在没有中央集权机构发行货币的情况下，提供了一种电子货币分配到流通领域的方法。

另外一个激励的来源则是交易费(transaction fees)。如果某笔交易的输出值小于输入址，那么差额就是交易费，该交易费将被增加到该区块的激励中，只要既定数量的电子货币已经进入流通，那么激励机制就可以逐渐转换为完全依赖交易费，那么本货币系统就能够免于通货膨胀

激励系统也有助于估计节点保持诚实。


## 7. 回收硬盘空间
如果最近的交易已经被纳入了足够多的区块之中，那么就可以丢弃该交易之前的数据，以回收硬盘空间。

为了确保不损害区块的随机散列值，交易信息被散列的同时，被构建成一种Merkle树(Merkle tree)的形态，使得只有根(root)被纳入了区块的随机散列值。通过将该树(tree)的分支拔除(stubbing)的方法，老区块就能被压缩，而内部的随机散列值是不必保存的。

不包含交易信息的区块头(Block header)大小仅有80字节。假设区块生成的速率为10min一个，那么一年产生的数据为4.2MB，将全部的区块头存储于内存都不是问题


## 8. 简化的支付确认(Simplified Payment Verification)
在不运行完整网络节点的情况下，也能够对支付进行校验。一个用户需要保留最长的工作量证明链条的区块头的拷贝，它可以不断向网络发起询问，知道它确信自己拥有最长的链条，并能够通过merkle分支通向它被加上时间戳并纳入区块的那一次交易。

节点想要自行检验该交易的有效性原本是不可能的，但通过追溯到链条的某个为止，它就能看到某个节点曾经接受过它，并且于其后追加的区块也进一步证明全网曾经接受了它


## 9. 价值的组合与分(Combining and Splitting Value)
