## 第二部分 开发篇

### 第7章 表类型
5.5后默认InnoDB

##### 7.2.2 InnoDB

1. 自动增长列
对于InnoDB, 自动增长列必须是索引，如果是组合索引，必须是组合索引的第一项。

2. 外键约束
MySQL支持外键约束的只有InnoDB, 创建外键时，父表必须有对应的索引，子表在创建外键时也会自动创建对应索引

3. 存储方式
InnoDB存储表和索引有以下两种方式
+ 使用共享表空间存储，这种方式创建的表结构保存在.frm文件中，数据和索引保存在`innodb_data_home_dir`和`innodb_data_file_path`定义的表空间中，可以是多个文件。
+ 使用多表空间存储，表结构在.frm文件中，但是每个表的数据和索引单独保存在`.ibd`中。
如果是分区表，则每个分度对应单独的`.ibd`文件，文件名是`表名+分区名`，可以在创建分区的时候指定每个分区的数据文件的位置，以此来将表的IO均匀分布在多个磁盘上。


#### 7.3 如何选择合适的存储引擎
InnoDB：用于事务处理应用程序，对事务的完整性有较高要求，在并发时要求数据一致性，那么可以选择InnoDB, InnoDB除了有效的降低由于更新和删除导致的锁定，
还可以确保事务的完整提交和回滚。

### 第8章 选择合适的数据类型

#### 8.1 CHAR和VARCHAR
CHAR属于固定长度的字符类型，VARCHAR属于可变长度的字符类型

检索时，CHAR列删除了尾部的空格，优点是由于长度固定，所以处理速度快，去诶单是浪费存储空间，程序需要处理尾部空格。

在InnoDB中，建议使用过VARCHAR类型，因为内部的行存储格式并没有区分固定长度和可变长度的列，因此，本质上，使用CHAR的性能不一定要优于使用VARCHAR。
主要的性能因素是数据行使用的存储总量，所以使用占用空间较小的VARCHAR比较好

#### 8.2 TEXT和BLOB
TEXT只能保存字符串，BLOB能用来保存二进制数据，比如图片等。
+ BLOB和TEXT都会引起一些性能问题，特别是执行了大量的删除操作时，会在数据表中留下很大的空洞，以后填入这些空洞的记录在插入的性能上会有影响。
因此，建议定期使用`OPTIMIZE TABLE`功能对这类表进行碎片整理。
+ 可以使用合成的索引来提高大文本字段(BLOB或TEXT)的查询性能。就是为大文本字段内容建立一个散列值，并单独存储到一列中，
+ 在不必要的时候避免检索大型的BLOB或TEXT值
+ 把BLOB或TEXT列分离到单独的表中

#### 8.3 浮点数和定点数
浮点数 float, double，插入数据如果精度超过定义精度，自动四舍五入
定点数 decimal,实际以字符串形式存放

在精度要求较高的应用中，使用定点数而不是浮点数，因为浮点数会有精度的误差。

#### 8.4 日期类型选择
DATE, TIME, DATETIME, TIMESTAMP
如果要记录年份较久远，最好使用DATETIME，因为TIMESTAMP表示的日期范围要短
如果记录的日期要让不同时区的用户使用，最好使用TIMESTAMP, 只有它能和实际时区对应


### 第9章 字符集

#### 9.4 选择合适的字符集
+ 满足应用支持语言的需求，如果需要处理各种文字，或者发布到不用语言的地区，选择UTF-8
+ 如果应用中涉及已有数据的导入，需要考虑字符集对已有数据的兼容性。比如已有数据是GBK文字，如果选择GB2312-80位字符集，那么久会出现某些文字无法导入
+ 如果数据库只需要支持一般中文，且数据量大，性能要求高，那么就可以选择双字节定长编码的GBK，这样比UTF-8的汉字编码要少1个字节（GBK汉字2个字节，UTF8汉字3个字节）
+ 如果需要做大量的字符运算，比如比较、排序等，那么优先选择定长字符集，处理速度更快
+ 如果客户端程序都支持相同的字符集，那么优先选择该字符集避免因为字符集转换带来的开销和数据损失

#### 9.5 MySQL支持的字符集
MYSQL字符集包括字符集(CHARACTER)和校对规则(COLLATION)2个概念。
其中字符集用来定义MYSQL存储字符串的方式，校对规则用来定义比较字符串的方式。

每个字符集至少对应1个校对规则。校对规则命名约定：
相关字符集名 + 语言名 + _ci(大小写不敏感) | _cs(大小写敏感) | _bin(基于字符串编码值比较)


### 第10章 索引的设计和使用

#### 10.1 索引概述
每种存储引擎对每个表支持至少16个索引，总索引长度至少为256字节。

InnoDB的表默认创建的是BTREE索引，也支持前缀索引，即对索引字段的前N个字符创建索引。InnoDB中，索引前缀长度最长767字节。

#### 10.2 设计索引的原则
+ 搜索的索引列，不一定是所要选择的列。也就是说最合适索引的列式出现在WHERE子句中的列，或链接字句中的列，而不是出现在SELECT关键字后的选择列表中的列
+ 使用唯一索引，考虑值的分布，索引的列的基数越大，索引效果就越好。
+ 使用短索引，如果对字符串列进行索引，指定一个前缀长度，比如一个CHAR(200)的列，前缀取10~20个字符即可
+ 利用最左前缀，在创建一个n列的索引时，实际上是创建了MYSQL可利用的n个索引，多列索引可起几个索引的作用，利用索引中最左边的列集来匹配行
+ 不要过度索引，每个额外的索引都要占用额外的磁盘空间，降低写性能。MYSQL在生成一个执行计划时，会对索引进行考虑，如果索引需要花费工作太多，可能就选择不到最好的索引。
+ 对于InnoDB的表，记录默认按照一定顺序保存，如果有明确的主键，按照主键顺序保存，如果没有主键，但是有唯一索引，那么按照唯一索引顺序保存，否则，表中会自动生成一个内部列，按照这个列的顺序保存。
按照主键或者内部列的访问时最快的，所以InnoDB尽量自己指定主键，提高查询效率。另外，InnoDB的普通索引都会保存主键的键值，因此，主键需要尽可能短的数据类型，减少索引的磁盘占用，
提高索引缓存效果

#### BTREE索引与HASH索引
HASH索引一些特征如下：
+ 只用于 = 或 <=> 操作符的等式比较
+ 优化器不能使用HASH索引来加速ORDER BY操作
+ MYSQL不能确定两个值之间的行数，如果将一个MYISAM表改为HASH索引的MEMORY表，会影响查询效率
+ 只能使用整个关键字来搜索一行

而BTREE索引，使用>, <, >=, <=, BETWEEMN, !=或者<>, LIKE `pattern`时(pattern不是通配符开头)，都可以使用相关列上的索引


### 第14章 事务控制和锁定语句

MYSQL支持对InnoDB的表进行行级锁定


#### 14.3 分布式事务的使用
分布式事务只支持InnoDB

##### 14.3.1 分布式事务的原理
在MYSQL中，分布式事务设计一个或多个资源管理器，以及一个事务管理器
+ 资源管理器(RM)，用于提供通向事务资源的途径，数据库服务器就是一种资源管理器，该管理器必须可以提交或者回滚由资源管理器管理的事务，
比如多台MYSQL数据库作为多台资源管理器
+ 事务管理器(TM)，用于协调作为一个分布式事务一部分的事务。事务管理器与管理每个事务的资源管理器进行通信。在一个分布式事务中，
各个单个事务都是分布式事务的分支事务。

MYSQL执行XA MYSQL时，MYSQL服务器相当于一个用于管理分布式事务中的XA事务的资源管理器，与MYSQL连接的客户端相当于事务管理器

要执行一个分布式事务，必须要知道这个事务涉及了哪些资源管理器，并且把每个资源管理器的事务执行到事务被提交或者回滚。

用于执行分布式事务的过程使用`两阶段提交`，发生时间在由分布式事务的各个分支需要进行的行动已经被执行后
+ 第一阶段，所有分支被预备好，即它们被TM告知要准备提交。意味着用于管理分支的每个RM会记录对于被稳定保存的分支的行动，分支指示是否它们可以这么做，
结果被用于第二阶段
+ 第二阶段，TM告知RMs是否要提交或回滚，如果在预备分支时，所有分支指示它们能够提交，则所有的分支被告知要提交。
如果在预备时，有任何分支指示不能提交，则所有分支被告知回滚


### 第17章 MySQL分区
根据一定规则，将一个表分解成多个更小的，容易管理的部分，对业务逻辑透明。

分区的优点：
+ 存储更多数据
+ 优化查询，在WHERE子句中包含分区条件时，可以只扫描必要的一个或多个分区来提高查询效率；同时在涉及SUM和COUNT聚合函数的查询时，可以容易的在分区上并行
+ 对于已经过期或者不需要保存的数据，可以通过删除与这些数据有关的分区来快速删除
+ 跨多个磁盘来分散数查询，获取更大查询吞吐量

使用ENGINE子句来设置分区。
```
ENGINE=INNODB
PARTITION BY HASH(MONTH(birth_date))
PARTITION 6
```

#### 17.2 分区类型
+ RANGE分区：基于一个给定的连续区间范围，将数据分配到不同分区
+ LIST分区：类似RANGE分区，区别是LIST分区是基于枚举值，RANGE分区基于范围值
+ HASH分区：基于给定的分区个数，哈希到不同分区
+ KEY分区：类似HASH分区

无论哪种分区类型，要么分区表上没有主键/唯一键，要么分区表的主键/唯一键必须包含分区键，
也就是说不能使用主键/唯一键字段之外的其他字段分区

Columns分区支持了多种类型：
+ 所有整数类型
+ 日期时间类型, data和dtetime
+ 字符类型，不支持text和blob


### 第18章 SQL优化

#### 18.1 优化SQL语句的一般步骤

##### 18.1.1 通过show status了解各种SQL执行效率
`show status like 'com_%'`
com_xxx表示每个xxx语句执行的次数，比较关心的是：
+ Com_select
+ Com_insert
+ Com_update
+ Com_delete
针对InnoDB，还会有如下几个操作统计
+ Innodb_rows_read: SELECT查询返回的行数
+ Innodb_rows_inserted
+ Innodb_rows_updated
+ Innodb_rows_deleted

这样很容易了解当前数据库是以插入更新为主还是以查询为主。

对于事务型应用，通过Com_commit和Com_rollback了解事务提交和回滚情况，对于回滚非常频繁的数据库，可能意味着应用编写有问题

##### 18.1.2 定位执行效率较低的SQL语句
+ 通过慢日志查询
+ 慢日志查询在查询结束以后才记录，不能实时定位问题。可以使用show processlist来查看当前MYSQL正在进行的线程，包括状态，是否锁表等

##### 18.1.3 通过EXPLAIN分析低效SQL的执行计划
给出的结果字段如下：
+ select_type: SELECT的类型，常见取值有SIMPLE(简单表，不使用连接或者子查询)、PRIMARY(主查询，即外层的查询)、UNION(UNION中第二个或后面的查询语句)、
SUBQUERY(子查询中的第一个SELECT)等
+ table: 输出结果集的表
+ type: MYSQL在表中找到所需行的方式，或者叫访问类型，常见类型如下：
    + ALL: 全表扫描
    + index: 索引全扫描，遍历整个索引来查询匹配的行
    + range：索引范围扫描，常见于<，>, between等操作
    + ref: 使用非唯一索引扫描或者唯一索引的前缀扫描，返回匹配某个单独值的记录行
    + eq_ref: 类似ref, 区别是使用的索引是唯一索引，对于每个索引键值，表中只有1条记录匹配，简单来说，就是多表连接中使用primary key或unique index作为了关联条件
    + const/system: 单表中最多有一行匹配，查询起来非常迅速，所以这个匹配行中的其他列的值看，而已被优化器在当前查询中当做常量来处理，比如根据主键或者唯一索引进行的查询
    + NULL: 不用访问表或者索引，直接能得到结果
+ possible_keys: 表示查询时可能使用的索引
+ key: 表示实际使用的索引
+ ken_len: 使用到索引字段的长度
+ rows: 扫描行的数量
+ Extra: 执行情况的说明和描述

使用`explain extended`命令，然后使用`show warnings`可以看到SQL在被真正执行之前做了哪些改写.
结果中多了filtered字段，同时，warning的message字段可以看到优化器最终改写的SQL。

有时候，仅通过explain并不能快速定位SQL的问题。需要选择profile联合分析

##### 18.1.4 通过show profile分析SQL
通过show profile for query [queryID]可以看到执行过程中的每个状态和消耗时间

##### 18.1.5 通过trace分析优化器如何选择执行计划
MySQL5.6提供了对SQL的跟踪。使用方式：
首先打开trace, 设置为JSON格式，设置最大使用的内存大小；
```
SET OPTIMIZER_TRACE="enabled=on", END_MARKERS_IN_JSON=on;
SET OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;
```
然后执行要trace的SQL语句；
最后检查`INFORMATION_SCHEMA.OPTIMIZER_TRACE`表就可以知道是如何执行SQL的


#### 18.2 索引问题

##### 18.2.1 索引的存储分类
MYSQL目前提供了4种索引：
1. BTREE索引，最常见的索引类型，大部分引擎都支持
2. HASH索引，只有Memory引擎支持
3. RTREE索引，MyISAM的一种特殊索引类型
4. Full-text索引，全文索引，InndDB从5.6开始支持

##### 18.2.2 MYSQL如何使用索引
以最常见的BTREE为例。BTREE即平衡树。并不是二叉树。

1. MYSQL中能够使用索引的典型场景
+ 匹配全值，对索引中所有列都指定具体值
+ 匹配值的范围查询，对索引的值能够进行范围查找
+ 匹配最左前缀，仅仅使用索引中最左边列进行查找，是BTREE索引使用的首要原则
比如创建(col1, col2, col3)的联合索引，可以被包含(col1), (col1, col2), (col1, col2, col3)的等值查询到，但是不能被(col2), (col2, col3)的等值查询到
+ 仅仅对索引进行查询，当查询的列都在索引的字段中时，查询的效率更高。Extra字段会变成`Using index`，表明仅仅通过索引就可以获得所需要的所有数据，不需要通过索引回表再去获取其他列值
+ 匹配列前缀，仅仅使用索引的第一列，并且只包含索引第一列的开头一部分进行查找，Extra字段是`Using where`表优化器需要通过索引回表查询数据
+ 能够实现索引匹配部分精确而其他部分进行范围查找
+ 如果列名是索引，那么使用column_name is null就会使用索引
+ MySQL5.6引入了Index Condition Pushdown特性，进一步优化了查询。可以让某些情况下的条件过滤操作下放到存储引擎

2. 存在索引但不能使用索引的典型场景
+ 以%开头的LIKE查询不能够利用BTree索引，执行计划中key为NULL
+ 数据类型出现隐式转换时也不会使用索引，特别当列类型是字符串时，那么一定记得在WHERE条件中把字符串常量用引号引起来，否则即便这个列上有索引，MYSQL也不会用到
+ 复合索引情况下，假如查询条件不包含索引列的最左边部分，即不满足最左原则，那就不会使用复合索引
+ 如果MYSQL估计使用索引比扫描全表更慢，就不使用索引
+ 用`OR`分割开的条件，如果`OR`前的条件中的列有索引，之后的列中没有索引，那么涉及到的索引都不会被用到

##### 18.2.3 查看索引使用情况
如果索引正在工作，`Handle_read_key`的值会很高，代表一个行被索引值读的次数。
`Handler_read_rnd_next`的值高意味着查询运行低效，并且应该建立索引补救。

#### 18.3 2个简单使用的优化方法

##### 18.3.1 定期分析表和检查表
分析表：
```
ANALYZE [LOCAL|NO_WRITE_TO_BINLOG] TABLE tbl_name [,tbl_name]...
```
用于分析和存储表的关键字分布，分析结果可以得到准确的统计信息，使得SQL能够生成正确的执行计划。

检查表：
```
CHECK TABLE tbl_name [,tbl_name]... [option]... option=[QUICK|FAST|MEDIUM|EXTENDED|CHANGED]
```
用于检查一个或多个表是否有错误

##### 18.3.2 定期优化表
```
OPTIMIZE [LOCAL|NO_WRITE_TO_BINLOG] TABLE tbl_name [,tbl_name]...
```
如果已经删除了表的一大部分，或者对含有可变长度行的表进行了很多修改(比如含有VARCHAR、BLOB或者TEXT列的表)，则应使用OPTIMIZE TABLE进行优化。
可以将表中的空间碎片进行合并，用于消除删除或更新造成的空间浪费。

对于InnoDB的表，通过设置`innodb_file_per_table`设置为独立表空间模式，这样每个数据库的每个表都会生成一个独立的`.ibd`文件，用于存储表的数据和索引。
减轻InnoDB表的空间回收问题。在删除大量数据之后，使用`ALTER TABLE TABLE_NAME engine=innodb`来进行回收空间

注意：以上优化执行都会锁表

#### 18.4 常用SQL的优化

##### 18.4.1 大批量插入数据
+ 对于InnoDB表，因为是按照主键的顺序存储，所以如果导入的数据是按照主键顺序排列的，那么可以有效的提高导入效率。
+ 在导入数据前执行`SET UNIQUE_CHECKS=0`关闭唯一性校验，导入结束后开启，可以提高导入效率
+ 如果是自动提交的方式，建议在导入前执行`SET AUTOCOMMIT=0`关闭自动提交，导入结束后再开启，也可以提高导入效率

##### 18.4.2 优化INSERT语句
+ 如果同时从同一客户端插入很很多行，应尽量使用多个值表的INSERT语句，将大大减少客户端与数据库的连接、关闭消耗。
+ 如果从不同客户端插入很多行，可以使用`INSERT DELAYED`语句得到更高的速度。
+ 将索引文件和数据文件分在不同磁盘上存放（建表语句的选项）
+ 当从一个文本文件装载一个表时，使用`LOAD DATA INFILE`会比使用很多INSERT语句快20倍

##### 18.4.3 优化ORDER BY语句
MYSQL中有2种排序方式：
1. 通过有序索引顺序扫描返回的有序数据，分析显示为Using Index, 不需要额外的排序，操作效率最高
2. 通过对返回数据进行排序，也就是Filesort排序。

尽量较少额外的排序，通过索引直接返回有序数据。WHERE和ORDER BY使用相同的索引，并且ORDER BY的顺序和索引顺序相同，并且ORDER BY的字段都是升序或者降序，否则肯定需要额外的排序操作

Filesort的优

Filesort不可能完全被避免，对于Filesort, MYSQL有两种排序算法：
1. 两次扫描算法：首先根据条件取出排序字段和行指针信息，之后在排序区sort buffer中排序，如果sort buffer不够，则在临时表中存储排序结果，
完成排序之后根据行指针回表读取记录，在MYSQL4.1之前采用。第二次读取会导致大量的随机IO，优点是排序内存开销较小。
2. 一次扫描算法：一次性取出满足条件的行的所有字段，然后在排序区排序后直接输出结果集。排序内存开销大，但效率高。

适当加大系统变量`max_length_for_sort_data`，能够让MYSQL选择更优化的Filesort排序算法。
适当加大`sort_buffer_size`排序区，尽量让排序在内存中完成，而不是创建临时表放在文件中进行。
尽量只使用必要的字段，减少排序区的使用。

##### 18.4.4 优化GROUP BY语句
默认情况下，MYSQL对所有GROUP BY col1, col2....的字段会进行排序。如果要禁止掉排序的消耗，可以指定`ORDER BY NULL`来禁止排序。

##### 18.4.5 优化嵌套查询
有些情况下，子查询可以被更高效的JOIN替代。是因为MYSQL不需要再内存中创建临时表来完成这个逻辑上分为几步的子查询

##### 18.4.6 MYSQL如何优化OR条件
对于含有OR的查询子句，如果要利用索引，必须每个列都要用到索引，如果没有，则考虑增加索引

##### 18.4.7 优化分页查询
一般分页查询时，创建覆盖索引可以较好的提高性能。
1. 第一种优化策略
在索引上完成排序分页的操作，最后根据主键关联回原表查询所需要的其他列内容

2. 第二种优化策略
把LIMIT查询转换成某个位置的查询。但是只适合排序字段不会重复的特定环境

##### 18.4.8 使用SQL提示
1. USING INDEX, 直接让MYSQL去参考指定索引，不考虑其他可用的索引
2. IGNORE INDEX, 让MYSQL忽略一个或多个索引
3. FORCE INDEX, 强制使用一个特定索引

#### 18.5 常用SQL技巧
##### 18.5.1 正则表达式的使用
MYSQL使用`REGEXP`命令给用户扩展的正则表达式功能。

##### 18.5.2 巧用RAND()提取随机行
`ORDER BY RAND()`

##### 18.5.3 利用GROUP BY的WITH ROLLUP子句
可以检索出本组类的整体聚合信息。注意，在使用ROLLUP时，不能同时使用ORDER BY子句。

##### 18.5.4 用BIT GROUP FUNCTIONS做统计
略

##### 18.5.5 数据库名、表名大小写问题
略

##### 18.5.6 使用外键需要注意的问题
略


### 第19章 优化数据库对象

#### 19.1 优化表的数据类型
使用函数`PROCEDURE ANALYSZE()`来对当前的表进行分析，会对表的列的数据类型提出优化建议。
```
SELECT * FROM tbl_name PROCEDURE ANALYSE()
```

#### 19.2 通过拆分提高表的访问效率
垂直拆分 & 水平拆分

#### 19.3 逆规范化
考虑到表之间的连接操作性能较低，所以可以考虑冗余一些字段避免做表关联，使查询效率更高

#### 19.4 使用中间表提高统计查询速度


### 第20章 锁问题

#### 20.1 MySQL锁概述
InnoDB既支持支持行级锁，也支持表级锁，但是默认采用行级锁

#### 20.3 InnoDB锁问题

并发事务处理带来的问题
+ 更新丢失，需要完全避免
+ 脏读
+ 不可重复读
+ 幻读

更新丢失需要完全避免，而脏读，不可重复读，幻读都是数据库读一致性的问题，必须由数据库提供一定的事务隔离机制来解决。
数据库实现事务隔离的方式，分为2类：
1. 在读取数据前，对其加锁，阻止其他事务对数据修改
2. 不加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照，并用这个快照来提供一定级别的一致性读取，从用户角度来看，
似乎是可以通过一个数据的多个版本，也称为数据多版本并发控制(MVCC)

MVCC是通过保存数据在某个时间点的快照来实现的，是行级锁的一个变种，但是在很多情况下避免了加锁操作，因此开销更低。

不同的存储引擎MVCC的实现是不同的，典型的有乐观并发控制和悲观并发控制。下面以InnoDB为例说明MVCC是如何工作的：

InnoDB的MVCC是通过在每行记录后保存2个隐藏的列来实现的：
+ 一个列保存了行的创建时间
+ 另一个保存行的过期时间(删除时间)
这些时间并不是实际的时间值，而是系统版本号。

每开始一个新的事务，系统版本号就会递增，事务开始时刻的系统版本号就作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

在MySQL默认事务隔离级别REPEATABLE READ级别下，MVCC的具体操作：
+ SELECT：InnoDB会根据以下两个条件检查每行记录
    + InnoDB只查找版本号遭遇当前事务版本的数据行，这样可以确保事务读取的行，要么是事务开始前存在的，要么是事务自身插入或者修改的
    + 行的删除版本要么未定义，要么大于当前事务版本号，这样可以保证事务读取到的行，在事务开始之前没有被删除
+ INSERT: InnoDB为新插入的每一行保存当前系统号作为行版本号
+ DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除表示
+ UPDATE：InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识

这样，大多数的读操作都可以不用加锁，使得读操作简单，性能好。
MVCC只在REPEATABLE READ和READ COMMITTED2个隔离级别下才正常工作。


为了解决"隔离"和"并发"的矛盾，ISO/ANSI SQL92定义了4个事务隔离级别
1. 未提交读(Read uncommitted)
2. 可提交读(Read committed)
3. 可重复读(Repeatable read) —— MySQL默认事务隔离级别，InnoDB采用MVCC支持高并发，并且使用间隙锁防止幻读
4. 可序列化(Serializable)

MYSQL支持全部的4个隔离级别

##### 20.3.2 获取InnoDB行锁争用情况
```
show status like 'innodb_row_lock%'
```
如果`InnoDB_row_waits`和`InnoDB_row_lock_time_avg`的值比较高，说明锁争用比较严重。如下步骤解决：
1. 查询`infomation_schema`数据库中的表了解锁等待情况
```
select * from innodb_locks;
select * from innodb_lock_waits;
```
2. 设置InnoDB Monitors观察锁冲突情况
```
create table innodb_monitor(a INT) ENGINE=INNODB;
// 查看
show engine innodb status;
// 停止
drop table innodb_monitor;
```

##### 20.3.3 InnoDB的行锁模式及加锁方法
InnoDB实现了以下2种类型的行锁
1. 共享锁(S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁
2. 排他锁(X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁
另外，为了允许行锁和表锁共存，实现多粒度机制，InnoDB还有两种内部使用的意向锁，这是InnoDB自动加的，不需要手动干预
1. 意向共享锁(IS): 事务打算给数据行加行共享锁之前，必须先取得该表的IS锁
2. 意向排它锁(IX): 事务打算给数据行加行排它锁之前，必须先取得该表的IX锁

对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排它锁(X);
对于普通SELECT语句，InnoDB不会加任何锁；

加共享锁: `SELECT * FROM tbl_name WHERE ... LOCK IN SHARE MODE;`
加排它锁: `SELECT * FROM tbl_name WHERE ... FOR UPDATE;`


##### 20.3.4 InnoDB行锁实现方式
InnoDB行锁是通过给索引上的索引项加锁来实现的，如果没有索引，会通过隐藏的聚簇索引来对记录加锁，InnoDB行锁分为3类：
1. Record lock: 对索引项加锁
2. Gap lock: 对索引项之间的间隙、第一条记录前的间隙或最后一条记录后的间隙加锁
3. Next-key lock: 前2种组合，对记录及其前面的间隙加锁

实际应用中，要特别注意InnoDB行锁的这一个特性：
1. 在不通过索引条件查询时，InnoDB会锁定表的所有记录（实际效果跟表锁一样）
2. 由于MYSQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然访问的是不同行的记录，但是如果使用的是相同的索引键，是会出现索引冲突的
3. 当表有多个索引时，不同的事务可以使用不同的索引锁定不同的行，但不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁
4. 即便在条件中使用了索引字段，但如果MYSQL认为扫描全表效率更高时，也不会使用索引。

##### 20.3.5 Next-Key锁
当使用的是范围条件而不是相等条件检索数据，并请求共享或排它锁时，InnoDB会给符合条件的已有数据记录的索引项加锁，
对于键值在条件范围内但不存在的记录，叫做"间隙"，InndDB也会对这个"间隙"加锁，这就是Next-Key锁

使用Next-Key的目的，一方面是为了防止幻读，满足隔离级别。另一方面，是为了满足其恢复和复制的需要。

显然的是，这种加锁机制往往会阻塞符合条件范围内键值的并发插入, 造成严重的锁等待。

特别的是，如果使用相等条件给一个不存在的记录加锁，InnoDB也会使用Next-Key锁

##### 20.3.6 恢复和复制的需要，对InnoDB锁机制的影响
MYSQL通过BINLOG记录执行成功的INSERT、UPDATE、DELETE等SQL语句。并由此实现MYSQL的恢复和主从复制。
MYSQL5.6支持3种日志格式，`基于语句的日志格式SBL`，`基于行的日志的RBL`和`混合格式`。
以及支持4种复制模式：
1. 基于SQL语句的复制SBR
2. 基于行数据的赋值RBR：MYSQL5.1以后开始支持，优点是支持对非安全SQL的复制
3. 混合复制模式：对安全的SQL语句采用基于SQL语句的复制，对非安全的采用RBR模式
4. 使用全局事务ID的复制：主要解决主从同步一致性问题

`INSERT... SELECT...`和`CREATE TABLE... SELECT...`语句，可能会阻塞对源表的并发更新，如果查询比较复杂，会造成严重的性能问题，尽量避免使用。
MYSQL将这种SQL称为不安全SQL，不推荐使用

##### 20.3.7 InnoDB在不同隔离级别下的一致性读及锁的差异
在不同级别下，InnoDB处理SQL采用的一致性读策略和需要的锁是不同的。

##### 20.3.8 什么时候使用表锁
InnoDB而言，绝大部分情况都应该使用行锁，个别特殊事务除外：
1. 事务需要更新大部分或者全部数据，表有比较大，如果使用默认的行锁，不仅当前事务执行效率低，还可能造成其他事务长时间锁等待和锁冲突，此时可考虑使用表锁
2. 事务涉及多个表，比较复杂，容易引起死锁，造成大量事务回滚，这种情况也可以考虑一次性锁住整个表。

在InnoDB中，使用表锁需要注意以下两点：
1. 使用LOCK TABLES虽然可以给InnoDB加表锁，但是，表锁 并不是InnoDB存储引擎层管理的，而是由其上一级MYSQL SERVER负责的。
仅当autocommit=0, innodb_table_locks=1时，InnoDB层才知道MYSQL加的表锁，MySQL Server也才能感知InnoDB加的行锁。
2. 在使用LOCK TABLES对InnoDB加表锁时，要将AUTOCOMMIT设置为0，否则无法加锁。事务结束之前，不要使用UNLOCK TABLES释放表锁，因为会隐含的提交事务。

##### 20.3.9 关于死锁
发生死锁后，InnoDB一般会检测到，并使一个事务释放锁并回滚，另一个事务获得锁，继续执行。但是，在涉及到外部锁或者表锁时，InnoDB并不能检测到死锁。
因此需要设置锁等待超时参数`innodb_lock_wait_timeout`来避免大量挂起的事务占用资源。

下面介绍几种避免死锁的常用方法：
1. 应用中，如果不同程序会并发的存取多个表，应尽量约定相同的顺序来访问表
2. 在程序以批量处理数据时，如果实现对数据排序，保证每个线程按照固定的顺序来处理，也可以大大降低死锁的可能
3. 在事务中，如果要更新记录，直接申请足够级别的锁，即排他锁
4. 在可重复读的隔离级别下，如果两个线程对相同条件记录用`SELECT ...FOR UPDATE`加排它锁，且没有符合条件记录的情况下，两个线程都会加锁成功。
如果此时两个线程都尝试插入一条新纪录，就会发生死锁，那么就需要将隔离级别改成`READ COMMITTED`级别。
5. 当隔离级别为`READ COMMITTED`时，如果两个线程都先执行`SELECT ... FOR UPDATE`，判断是否存在符合条件的记录，如果没有，就插入记录。
只会有1个线程插入成功，另一个会出现锁等待，当第一个线程提交后，第2个线程会出现主键重复错误，虽然这个线程出错了，**却会获得一个排他锁!!!**,
如果此时，有第三个线程又来申请排他锁，那么也会出现死锁。


### 第21章 优化MySQL Server
默认情况下，MYSQL有7组后台线程，1个主线程、4组IO线程、1个锁线程、1个错误监控线程、1个purge线程，主要功能如下：
1. master thread: 主要负责将脏缓存页刷新到数据文件，执行purge操作，触发检查点，合并插入缓冲区等
2. insert buffer thread: 主要负责插入缓冲区的合并操作
3. read thread: 负责数据库读取操作，可配置多个
4. write thread: 负责数据库写操作，可配置多个
5. log thread: 将重做日志刷新到logfile中
6. purge thread: 执行Purge操作
7. lock thread: 锁控制和死锁检测等
8. 错误监控线程：错误监控和处理

#### 21.2 MySQL内存管理及优化
内存优化原则：
1. 将尽量多的内存分配给MYSQL做缓存，但要给操作系统和其他程序预留足够的内存，否则产生SWAP页交换，影响性能
2. 排序区、连接区等缓存是分配给每个数据库连接会话专用的，默认值的设置需要根据最大连接数合理分配

##### 21.2.3 InnoDB内存优化

1. InnoDB缓存机制
InnoDB使用一块内存区用作IO缓冲池，缓存InnoDB的索引块以及数据块。

InnoDB缓存池逻辑上由freelist, flushlist和LRU list组成。
+ freelist: 空闲缓存块列表
+ flushlist: 需要刷新到磁盘的缓存块列表
+ LRU list: InnoDB正在使用的缓存块。优先淘汰尾部较少访问的索引块
    + young sublist
    + old sublist
    
脏页的刷新存在于flush list和LRU list这2个表，默认InnoDB buffer pool中不存在可用的数据页时，会扫描LRU list尾部的innodb_lru_scan_depth个数据页(默认1024),
进行相关刷新操作。

可以通过调整InnoDB buffer pool的大小，改变young sublist和old sublist的分配比例、控制脏缓存的刷新活动、使用多个InnoDB缓存池的方法来优化InnoDB的性能。

2. innodb_buffer_pool_size的设置
innodb_buffer_pool_size决定InnoDB表数据和索引数据的最大缓存区大小。这个值越大，缓存命中率就越高，一般可以将80%的物理内存分配给InnoDB buffer pool.

3. 调整old sublist大小
在LRU中，old sublist的比例由`innodb_old_blocks_pct`决定，取值5~95，默认37

4. 调整innodb_old_blocks_time的设置
决定了缓存数据块由old sublist转移到young sublist的快慢

5. 调整缓存池数量，减少内部对缓存池数据结构的争用
MYSQL内部不同线程对InnoDB缓存池的访问在某些阶段是互斥的，这种内部竞争也会产生性能问题，尤其是在高并发和buffer pool较大的情况下。
适当的增大`innodb_buffer_pool_instances`参数，可以降低并发导致的内部缓存访问冲突。

6. 控制innodb buffer刷新，延长数据缓存时间，减缓磁盘IO
在InnoDB找不到感觉的可缓存页或者检查点被触发时，InnoDB后台线程会开始把脏的缓存页回写到磁盘，这个过程叫"缓存刷新"

7. InnoDB doublewrite
在进行脏也刷新时，InnoDB采用了double write策略。由于MYSQL的页大小与OS的页大小一般不一致，因此无法保证InnoDB缓存页完整的刷新到磁盘。

double write机制原理是：
用系统表空间的一块练习磁盘空间，100个连续页，大小2MB作为double write buffer；
当进行脏页刷新时，首先将脏页的副本写到系统表空间的doublewrite buffer中，然后调用fsync()刷新操作系统IO缓存，确保副本被真正写入磁盘；
最后InnoDB后台IO线程将脏页刷新到磁盘文件；
恢复数据时，如果发现不一致的页，会用系统表空间doublewrite buffer区对应的副本来恢复数据页

#### 21.3 InnoDB log机制及优化

##### 21.3.1 InnoDB重做日志
redo log是InnoDB保证事务ACID属性的重要机制。
当更新数据时，InnoDB内部操作流程大致如下：
1. 将数据读入InnoDB buffer pool, 并对相关记录加独占锁
2. 将UNDO信息写入undo表空间的回滚字段
3. 更改缓存页中的数据，将更新记录写入redo buffer中
4. 提交时，根据innodb_flush_log_at_trx_commit`的设置，用不同的方式将redo buffer中的更新记录刷新到InnoDB的redo log file中，然后释放独占锁
5. 后台IO线程根据需要择机将缓存中更新过的数据刷新到磁盘


#### 21.4 调整MYSQL并发相关的参数
+ max_connections: 提高并发连接，默认151。如果`connection_errors_max_connections`不为0且一直增长，应考虑增大`max_connections`的值
+ back_log: 控制MYSQL监听TCP端口时设置的积压请求栈的代销，默认`(max_connections/5)`, 但最大不超过900. 如果需要在短时间内处理大量请求连接，可考虑适当增大该值
+ table_open_cache: 每个SQL执行线程都至少要打开1个表缓存，参数`table_open_cache`控制所有SQL执行线程时可打开表缓存的总数量，
如果在未执行flush tables情况下，MYSQL状态变量`opened_tables`的值较大，说明`table_open_cache`设置的太小，可适当增大
+ thread_cache_size: MYSQL缓存一定数量的客户服务线程，来加快数据库连接的速度。当cache的失效率`threads_created/connections`来衡量`thread_cache_size`是否合理，
如果接近1，说明cache命中率低，可适当增大
+ innodb_lock_wait_timeout: 控制等待行锁的时间，默认50ms


### 第31章 MYSQL复制
todo

### 第32章 MYSQL CLUSTER
todo

### 第33章 高可用架构
todo






