## redis设计与实现

### 第2章 简单动态字符串
没有直接使用C语言传统字符串，而是自己构建了一种简单动态字符串SDS的抽象类型

举例如下：
```
redis> set msg "hello world"
```
那么Redis将在数据库中创建一个键值对，其中：
+ 键值对的键值是一个字符串对象，对象的底层实现是一个保存着字符串"msg"的SDS
+ 键值对的值也是一个字符串对象，底层实现是一个保存着字符串"hello world"的SDS

除了用了保存数据库中的字符串值之外，SDS还被用作缓冲区：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是SDS实现的

#### 2.1 SDS的定义
```
struct sdshdr {
    int len;    // 记录buf数组中已经使用的字节数，相当于SDS所保存的字符串的长度
    int free;   // 记录buf数组中未使用的字节数
    char buf[]; // 用于保存字符串
```

#### 2.2 SDS与C字符串的区别
C采用N+1的字符数组来表示长度N的字符串，但是不适合Redis

##### 2.2.1 常数复杂度获取字符串长度
C字符串获取长度的操作复杂度是O(N); 而SDS获取长度复杂度O(1).
这样确保了获取字符串长度不会成为Redis的性能瓶颈

##### 2.2.2 杜绝缓冲区溢出
C字符串不记录自身长度带来的另一个问题就是容易操作缓冲区溢出。
比如`char *strcat(char *dest, char *src);`函数中，如果没有给dest分配足够的内存，那么dest的数据将溢出到它响铃的空间中。

而SDS的空间分配策略杜绝了发生缓冲区溢出的可能，当需要对SDS修改时，会先检查SDS的空间是否满足修改所需，如果不满足，
会自动将SDS的空间扩展，然后再执行时间的修改。

##### 2.2.3 减少修改字符串时带来的内存重分配次数
C字符串的长度和底层数组的长度存在着关联性，所以每次增长或者缩短一个C字符串，程序都要对这个C字符串的数据进行一次内存重分配操作
+ 增长操作：在操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小，否则会产生缓冲区溢出
+ 缩短操作：在操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间，否则会产生内存泄露

Redis中，数据会被频繁修改，所以如果每次修改字符串的长度都要执行一次内存重分配的话，会对性能造成影响。
为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度的关联。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略
1. 空间预分配： 当SDS的API对一个SDS修改并且需要扩展时，程序不仅会为SDS分配修改所必须的空间，还会分配额外的未使用空间
    + 如果修改后，SDS的长度<1MB, 那么程序会分配和len属性同样大小的未使用空间
    + 如果修改后，SDS的长度>=1MB, 程序会分配1MB的未使用空间
2. 惰性空间释放：用于优化SDS字符串缩短操作，当SDS的API缩短SDS所保存的字符串时，程序不会立即使用内存重分配来回收缩短后不需要用到的字节，
而是使用free属性将这些字节数量记录起来，等待将来使用

##### 2.2.4 二进制安全
所有SDS的API都会以处理二进制的方式来处理SDS存放在buf数组里的数据

##### 2.2.5 兼容部分C字符串函数



### 第3章 链表
列表键的底层实现之一就是链表，当一个列表键包含了比较多的元素，或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为底层实现

#### 3.1 链表和链表节点的实现
```
typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;

typedef struct list {
    listNode *head;
    listNode *tail;
    unsigned long len;  // 链表所包含节点的数量
    void *(*dup)(void *ptr);    // 节点值复制函数
    void *(*free)(void *ptr);   // 节点值释放函数
    int (*match)(void *ptr, void *key); // 节点值对比函数
} list;
```


### 第4章 字典
Redis的数据库就是用字典来作为底层是实现。
当执行`set msg "hello world`时，会在数据库中创建一个键值为"msg", 值为"hello world"的键值对，这个键值对就保存在代表数据库的字典里

除了用来表示数据库，字典还是哈希键的底层实现之一，当一个哈希键包含的键值较多，或者键值对中都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现

#### 4.1 字典的实现
Redis的字典使用哈希表作为底层实现

##### 4.1.1 哈希表
```
typedef struct dictht {
    dictEntry **table;  // 哈希表数组（也就是bucket)
    unsigned long size; // 哈希表大小
    unsigned long sizemask; // 哈希表大小掩码，用于计算索引值，总是=size-1
    unsigned long used; // 哈希表已有节点数量
} dictht
```
table是一个dictEntry结构的指针数组，每个dictEntry保存着一个键值对。

##### 4.1.2 哈希表节点
哈希表节点就是dictEntry结构，每个保存着一个键值对
```
typedef struct dictEntry {
    void *key;  // 键
    union {     
        void *val;
        uint64_tu64;
        int64_ts64;
    } v;    // 值
    struct dictEntry *next; // 指向下个节点，形成链表
} dictEntry;
```
v是键值对的值，可以是一个指针，或者一个uint64_t整数，或者int64_t整数。
next是指向另一个哈希节点的指针，可以将多个哈希值相同的键值对连接在一起，解决键冲突问题

##### 4.1.3 字典
```
typedef struct dict {
    dictType *type; // 类型特定函数
    void *privdata; // 私有数据
    dictht ht[2];   // 哈希表
    int rehashidx; // rehash索引
} dict;
```
其中，type是一个dictType结构的指针，每个dictType保存了一簇用于操作特定类型键值对的函数，redis会为用途不同的字典设置不同的类型特定函数
```
typedef struct dictType {
    unsigned int (*hashFunction)(const void *key);  // 计算哈希值的函数
    void *(*keyDup)(void *privdata, const void *key);   // 复制键的函数
    void *(*valDup)(void *privdata, const void *obj);   // 复制值的函数
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);  // 对比键的函数
    void (*keyDestructor)(void *privdata, void *key);   // 销毁键的函数
    void (*valDestructor)(void *privdata, void *obj);   // 销毁值的函数
} dictType;
```
+ ht: 一般只用ht[0]哈希表，ht[1]只在rehash的时候使用
+ trehashidx: 记录了rehash的进度，如果当前没有rehash在进行，就是-1


#### 4.2 哈希算法
要将一个新的键值对添加到字典里面，程序先要根据键值计算出哈希值和索引值，然后在根据索引值，将包含这个键值对的哈希表节点放到哈希表数组指定的索引上。
```
// 计算key的哈希值
hash = dict->type->hashFunction(key);
// 根据哈希表的sizemask和哈希值，计算出索引值
index = hash * dict->ht[x].sizemask;    // x可以是0或1
```

当字典被用作数据库底层， 或者哈希键的底层实现时，redis使用MurmurHash2算法来计算哈希值


#### 4.3 解决键冲突
redis采用链地址法来解决键冲突。然后放在最前面

#### 4.4 rehash
为了让负载因子维持在一个合理范围之内，当哈希表保存的键值对数据太多或者太少的时候，程序需要对哈希表的大小相应的扩展或者收缩。

redis对字典的哈希表执行rehash的步骤如下:
1. 为字典的ht[1]哈希表分配空间，大小取决于要执行的操作，以及ht[0]当前包含的键值对的数量
    + 如果是扩展操作，那么ht[1]的大小为**第一个大于等于ht[0].used*2的2的n次方幂**
    + 如果是收缩操作，ht[1]的大小为第一个大于等于ht[0].used的2的n次方幂
2. 将保存在ht[0]中的所有键值对rehash到ht[1]
3. 当ht[0]全部都rehash到ht[1]上后，释放ht[0], 将ht[1]设置为ht[0], 并在ht[1]上新建一个空白哈希表，为下一次rehash准备

##### 何时扩展和收缩
当以下任意一个条件满足时，程序会自动对哈希表执行扩展操作
1. 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表负载因子>=1
2. 服务器正在执行BGSAVE命令或者BGREWRITEAOF命令，并且负载因子>=5

负载因子: `load_factor = ht[0].used / ht[0].size`

另外，当负载因子<0.1时，程序自动对哈希表执行收缩操作

#### 4.5 渐进式rehash
服务器是分批次的，渐进的将ht[0]里的键值对rehash到ht[1]的。
1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表
2. 在字典中维持着一个索引计数器rehashidx, 设置为0
3. 在rehash期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作之外，还会顺带将ht[0]表在rehashidx索引上的所有键值对
rehash到ht[1], 然后将rehashidx增1
4. 随着字典操作不断进行，最终ht[0]的值都会被rehash到ht[1], 然后将rehashidx设置为-1，表示rehash完成

在rehash过程中，查找会先在ht[0]里，如果没找到，再去ht[1], 而新添加的键值对只会添加在ht[1]上。


### 第5章 跳跃表
跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问

redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，或者有序集合中元素的成员都是比较长的字符串时，
Redis会采用跳跃表来作为底层实现。

Redis只在2个地方用到了跳跃表，一个是有序集合键，另一个是在集群节点中用作内部数据结构。

#### 5.1 跳跃表的实现
zskiplist结构: 跳跃表节点相关信息
+ header: 跳跃表表头节点
+ tail: 跳跃表表尾节点
+ level: 跳跃表内最大的层数(表头节点不算在内)
+ length: 记录跳跃表长度(表头节点不算在内)

zskiplistNode结构: 跳跃表节点
+ level: 层，用L1，L2,L3,L4标记节点的各个层，每个层都有2个属性: 前进指针和跨度
    + 前进指针：用于访问位于表尾方向的其他节点
    + 跨度：记录前进指针所指向的节点和当前节点的距离
+ backward: 后退指针，用BW标记的后退指针，指向位于当前节点的前一个节点
+ score: 分值，跳跃表中，节点按各自所保存的分值从小到大排列
+ obj: 成员对象，各个节点中所保存的成员对象

##### 5.1.1 跳跃表节点
```
typedef struct zskiplistNode {
    // 层
    struct zskiplistLevel {
        struct zskiplistNode *forward;  // 前进指针
        unsigned int span;  // 跨度
    } level[];
    
    struct zskiplistNode *backward; // 后退指针
    double score;   // 分值
    robj *obj;  // 成员对象
} zskiplistNode;
```
1. 层：跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，可以通过这些层来加快访问其他节点的速度。
每次创建一个新的跳跃表节点时，程序会根据幂次定律，随机生成一个1~32之间的值作为level数组的大小，这个大小就是层的高度
2. 前进指针：每一层都有一个指向表尾方向的前进指针`level[i].forward`
3. 跨度：层的跨度`level[i].span`，用于记录两个节点之间的距离。用来计算rank的：在查找某个节点过程中，将沿途访问过的所有层的跨度累计起来，就是目标节点在跳跃表中的rank
4. 后退指针：方便从表尾向表头遍历跳跃表的节点
5. 分值和成员：分值是一个double型，所有节点都按照分值从小到大排序；节点的成员对象是一个指针，指向一个字符串独享，字符串独享保存着一个SDS值

##### 5.1.2 跳跃表
使用一个zskiplist结构来管理持有这些跳跃表节点，就可以方便的对整个跳跃表进行处理
```
typedef struct zskiplist {
    struct zskiplistNode *header, *tail;    // 表头、表尾节点
    unsigned long length;   // 表中节点数量
    int level;  // 最大的节点层数
} zskiplist;
```


### 第6章 整数集合
如果一个集合只包含整数值元素，并且数量不多，Redis就会使用整数集合做为集合键的底层实现

#### 6.1 整数集合的实现
整数集合是Redis保存整数值的集合的抽象数据结构，可以保存类型为`int16_t`, `int32_t`, `int64_t`类型的整数，并且不会重复
```
typedef struct intset {
    uint32_t encoding;  // 编码方式
    uint32_t length;    // 元素数量
    int8_t contents[];  // 保存元素的数组
} intset;
```
+ contents: 整数几个的每个元素都是contents数组中的一项，各个项按照值的大小从小到大排序，并且不包含任何重复项
+ length: contents的长度

#### 6.2 升级
如果将一个新元素添加到整数集合里，并且新元素的类型比现有所有的类型都要长，那么整数集合就需要先进行升级，才能将新元素添加进来

升级并添加新元素共分为3步：
1. 根据新元素的类型，扩展整数集合底层数据的空间大小，并为新元素分配空间
2. 将底层所有元素都转成与新元素相同的类型，然后放到正确的位置上，维持底层数据有序性
3. 添加新元素到底层数组

整数集合不支持降级操作。


### 第7章 压缩列表
压缩列表ziplist是列表键和哈希键的底层实现之一。
当一个列表项只包含少量项，并且每个项要么就是小整数值，或者是比较短的字符串，那么redis就会使用压缩列表来作为列表键的底层实现；
当一个哈希键值包含少量键值对，并且每个键值对的键和值要么是小整数或者比较短的字符串，那么redis也会使用压缩列表来实现哈希键

#### 7.1 压缩列表的构成
为了节约内存而开发，由一系列特殊编码的连续内存块组成的额顺序型数据结构，一个压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者一个整数
+ zlbytes: 4字节，用于记录整个压缩列表占用的内存字节数
+ zltail: 4字节，用于记录压缩列表表尾节点距离压缩列表的起始地址有多少字节
+ zllen: 2字节，用于记录压缩列表包含的节点数量
+ entryX: 不定，压缩列表的各个节点，节点的长度由节点保存的内容决定
+ zlend: 1字节，0xFF, 用于标记压缩列表末端

#### 7.2 压缩列表节点的构成
每个节点可以保存一个字节数组或一个整数，其中，字节数组可以是以下三种长度：
+ 长度<=2^6-1字节的字节数组
+ 长度<=2^14-1字节的字节数组
+ 长度<=2^32-1字节的字节数组
整数可以是以下6种长度
+ 4位长，0~12之间的无符号整数
+ 1字节长的有符号整数
+ 3字节长的有符号整数
+ int16_t类型整数
+ int32_t类型整数
+ int64_t类型整数

每个压缩列表节点都由三个部分组成：
1. previous_entry_length: 记录压缩列表中前一个节点的长度，以字节为单位。
如果前一个节点长度<254, 那么这个字段长度就是1字节；如果前一个节点长度>=254字节，那么这个字段长度就是5字节，其中第一字节会被设置为0xFE.
程序可以根据通过指针运算，根据当前节点起始地址来计算出前一个节点的起始地址
2. encoding: 记录了节点的content属性所保存的数据的类型以及长度
    + 一字节、两字节或者5字节长，最高位为00，01或者10是字节数组编码，表示content属性保存着字节数组，数组的长度由这2位之后的其他位记录
    + 一字节长，最高位11开头，表示content保存着整数值，整数的类型和长度由其他位记录
3. content: 可以是一个字节数组或者整数，由encoding字段决定

#### 7.3 连锁更新
在添加新节点和删除节点时，都可能会引发连锁更新。最坏情况下需要执行N次空间重分配操作，每次分配空间最坏复杂度是O(N), 所以连锁更新最坏复杂度是O(N^2)

但是真正造成的性能问题的几率很低，可以忽略。


### 第8章 对象
前几章介绍了Redis用到的主要数据结构。但是Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统。
这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这5个类型

Redis使用对象的好处：
1. Redis在执行命令前，根据对象的类型来判断一个对象是否可用执行给定的命令
2. 根据不同场景选取不同的数据结构，优化使用效率
3. Redis对象系统还实现了基于引用计数的内存回收机制
4. 通过引用计数实现了对象共享机制，通过多个数据库建共享同一个对象来节约内存
5. Redis的对象带有访问时间记录信息，可用于计算数据库键的空转市场，在启用了maxmemory功能下，空转时间较大的键可能会被优先删除

#### 8.1 对象的类型和编码
每次在Redis创建一个键值对时，都至少会创建2个对象，一个是键对象，一个是值对象。
Redis中每个对象都由一个redisObject结构表示
```
typedef struct redisObject {
    unsigned type:4;    // 类型
    unsigned encoding:4;    // 编码
    void *ptr;  // 指向底层实现的数据结构的指针
    //...
} robj;
```

##### 8.1.1 类型
1. REDIS_STRING: 字符串
2. REDIS_LIST: 列表对象
3. REDIS_HASH: 哈希对象
4. REDIS_SET: 集合对象
5. REDIS_ZSET: 有序集合对象

对于键值来说，总是一个字符串对象，而值就可以是任一种对象。

##### 8.1.2 编码和底层实现
ptr指向对象的底层实现数据结构，这些数据结构由对象的encoding属性决定
1. REDIS_ENCODING_INT: long类型整数
2. REDIS_ENCODING_EMBSTR: embstr编码的简单动态字符串
3. REDIS_ENCODING_RAW: 简单动态字符串
4. REDIS_ENCODING_HT: 字典
5. REDIS_ENCODING_LINKEDLIST: 双端链表
6. REDIS_ENCODING_ZIPLIST: 压缩列表
7. REDIS_ENCODING_INTSET: 整数集合
8. REDIS_ENCODING_SKIPLIST: 跳跃表和字典

每种类型的对象都至少使用了两种不同的编码


#### 8.2 字符串对象
字符串对象的编码可以是int, raw或者embstr.
+ 如果一个字符串对象保存的是整数值，并且可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里，
并将编码设置为int.
+ 如果字符串对象保存的是一个字符串值，且长度>32字节，那么就使用一个SDS来保存这个字符串值，即将ptr指向一个SDS，并将编码设置为raw
+ 如果字符串对象保存的是一个字符串值，且长度<=32字节, 将使用embstr编码的方式来保存这个字符串值
和raw不同的时，raw编码会调用两次内存分配来分别创建redisObject结构和sdshdr结构，但embstr会调用一次内存分配来分配一块连续的空间，
依次包含redisObject和sdshdr两个结构。

##### 8.2.1 编码的转换
int编码和embstr编码的字符串对象会在条件满足的情况下转换为raw编码的字符串对象
```
set number 10086
OK

object encoding nunber
"int"

append number " is a good number"
(integer) 23

object encoding number
"raw"
```
embstr编码的字符串实际上是只读的，所以对embstr编码的字符串对象进行任何修改时，程序会先将embstr编码转为raw编码，然后再执行修改

##### 8.2.2 字符串命令的实现


#### 8.3 列表对象
列表对象的编码可以是ziplist或者linkedlist。
```
rpush numbers 1 "three" 6
(integer) 3

object encoding numbers
"ziplist"

# 增加很多元素之后，超过512个
object encoding numbers
"linkedlist"
```
ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点保存了一个列表元素；
linkedlist编码的列表对象使用双端链表作为底层实现，每个链表节点都保存了一个字符串对象

##### 8.3.1 编码转换
当满足以下两个条件时，列表对象使用ziplist编码：
1. 列表独享保存的所有字符串元素的长度都<64字节
2. 保存的元素数量<512个
注意：这2个上限值都是可以配置修改的

当不满足ziplist编码条件时，编码转换操作会自动执行，原本保存在压缩列表里的元素都会被转移到双端链表里


#### 8.4 哈希对象
哈希对象的编码可以是ziplist或者hashtable
ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，
然后再讲保存了值的压缩列表节点推入压缩列表表尾
+ 保存在同一键值对的两个节点物理上相连，保存键的节点在前，保存至的节点在后
+ 都是在表尾部添加

hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值都使用一个字典键值来保存

##### 8.4.1 编码转换
哈希对象可以同时满足以下两个条件时，使用ziplist编码
1. 保存的所有键值对的键和值的字符串长度都<64字节
2. 保存的截至对数量小于512个
注意：这2个上限值可以通过配置修改


#### 8.5 集合对象
集合对象的编码可以是intset或者hashtable
intset编码的集合对象使用整数集合作为底层实现
```
sadd numbers 1 3 5
(interger) 3
```
hashtable编码的集合对象使用字典作为底层实现，每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值全都被设置为NULL
```
sadd fruits "apple" "banana" "cherry"
(integer) 3
```

##### 8.5.1 编码转换
当集合对象同时满足以下两个条件时，使用intset编码
1. 所有元素都是整数值
2. 元素数量不超过512个
注意：上限值可以配置修改
```
sadd numbers 1 3 5
object encoding numbers
"intset"

sadd numbers "seven"
object encoding numbers
"hashtable"
```

#### 8.6 有序集合对象
有序集合对象的编码可以是ziplist或者skiplist
ziplist编码的有序集合对象使用压缩表作为底层实现，每个集合元素使用两个相邻的节点来保存，第一个保存member, 第二个保存score
压缩列表内的集合元素按照分值从小到大排序。分值越小，越靠近表头
```
zadd price 8.5 apple 5.0 banana 6.0 cherry
(integer) 3
```
skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表
```
typedef struct zset {
    zskiplist *zsl;
    dict *dict;
} zset;
```
其中，zsl跳跃表按照分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素；
此外，dict字段为有序集合创建了一个从成员到分值的映射，字典中的每一个键值对都保存了一个集合元素，这样，
程序就可以用O(1)的复杂度查找给定成员的score值

dict和zsl会通过指针共享相同元素的成员和分值，不会造成额外的内存浪费

##### 8.6.1 编码转换
当有序集合对象同时满足以下两个条件是，使用ziplist编码
1. 元素数量<128个
2. 所有元素成员的长度都<64字节
注意：上限值可以配置修改


#### 8.7 类型检查和命令多态
redis对于操作键的命令基本上分为两类：
1. 可以对任何类型的键执行，比如DEL, EXPIRE, RENAME, TYPE, OBJECT等
2. 只能对特定类型的键执行

##### 8.7.1 类型检查的实现
在执行一个类型特定的命令之前，redis会先检查输入建的类型是否正确，类型检查是通过redisObject的type属性来检查的

##### 8.7.2 多态命令的实现
对一个列表对象而言，有2种编码：ziplist和linkedlist.
当对一个键执行LLEN命令时，除了要保证键是列表键之外，还要根据键的值对象所使用的编码来选择正确的LLEN实现
+ ziplist: 对应压缩列表的ziplistlen函数
+ linkedlist:对应双端链表的listLength函数


#### 8.8 内存回收
Redis在自己的对象系统中构建了一个引用计数实现的内存回收机制。
每个对象的引用计数由redisObject的refcount记录
```
typedef struct redisObject {
    // ...
    int refcount;   // 引用计数
    // ...
} robj;
```

##### 8.9 对象共享
除了实现引用计数内存回收机制之外，对象的引用计数属性还可以对象共享。

目前Redis在初始化时，会创建10000个字符串对象，包含了从0~9999的所有整数值。
因此，当需要用到0~9999的字符串对象时，就会使用这些共享对象


##### 8.10 对象的空转市场
除了type, encoding, ptr和refcount之外，redisObject还有一个lru属性，记录了该对象最后一次被命令程序访问的时间
```
typedef struct redisObject {   
    // ...
    unsigned lru;
    // ...
} robj;
```
OBJECT IDLETIME命令可用打印出给定键值的空转时间
```
set msg "hello world"

object ideltime msg
(integer) 20

object ideltime msg
(integer) 180
```
注意：IDLETIME不会修改lru属性

如果服务器打开的maxmemory选项，并且服务器用于回收的算法是volatile-lru或者allkeys-lru是，那么空转时长较高的键会被优先释放，回收内存


### 第9章 数据库

#### 9.1 服务器中的数据库
redis服务器将所有数据库保存在db数组中，db数组每一项都是一个redisDb结构，代表一个数据库
```
struct redisServer {
    // ...
    redisDb *db;    // 数组，保存服务器中所有数据库
    
    int dbnum;  // 服务器的数据库数量
    // ...
}
```
在初始化服务器时，程序会根据服务器状态的dbnum来决定该创建多少个数据库，dbnum的值由服务器配置的database选项决定，默认16，即默认创建16个数据库

#### 9.2 切换数据库
客户端可以通过select来切换数据库，默认使用0号数据库

客户端状态redisClient的db属性记录了客户端当前使用的目标数据库
```
typedef struct redisClient {
    // ...
    redisDb *db;    // 指向redisServer.db数组中的一个元素
    // ...
} redisClient;
```

#### 9.3 数据库键空间
每个数据库由一个redisDb结构表示，其中redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间(key space)
```
typedef struct redisDb {
    // ...
    dict *dict; // 数据键空间，保存着数据库中的所有键值对
    // ...
} redisDb;
```

##### 9.3.6 读写键空间时的维护操作
当Redis对数据库进行读写时，服务器不仅会对键空间执行指定的操作，还会执行一些额外的维护操作，其中包括
+ 读取一个键之后，服务器会根据键是否存在来更新服务器的键空间命中次数和键空间不命中次数，可以通过INFO state命令的keyspace_hits属性和keyspace_misses查看
+ 读取一个键之后，服务器会更新键的LRU时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime <key>可以查看key的闲置时间
+ 如果读取一个键是发现该键已经过期，服务器会先删除这个过期键，然后再执行余下的操作
+ 如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为dirty，从而让事务程序注意到这个键已经被修改
+ 服务器每次修改一个键之后，都会对dirty键计数器+1， 这个计数器会触发服务器的持久化及复制操作
+ 如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知


#### 9.4 设置键的生存时间或过期时间
EXPIRE或PEXPIRE命令可用以秒、毫秒来为数据库中的某个键设置生存时间TTL
EXPIREAT或PEXPIREAT命令可用以秒、毫秒来设置某个键的过期时间

##### 9.4.1 设置过期时间
上面4个命令最终都会转换成PEXPIREAT来执行

##### 9.4.2 保存过期时间
redisDB结构的expires字典保存了数据库中所有键的过期时间，称为过期字典
```
typedef struct redisDb {
    // ...
    // dict *expires;   // 过期字典
    // ...
} redisDb;
```
+ 过期字典的键是一个指针，指向键空间中的某个键对象，不会造成空间浪费
+ 过期字典的值是一个long long类型的整数，——毫秒精度的unix时间戳

##### 9.4.5 过期键的判定
1. 检查给定键是否存在于过期字典，如果存在，取得键的过期时间
2. 检查当前UNIX时间戳是否大于键的过期时间，如果是，那么键已过期，否则未过期

#### 9.5 过期键删除策略
三种可能的删除策略：
1. 定时删除：在创建键的过期时间的同时，创建一个定时器，让定时器在过期时间来临，立即执行对键的删除操作
对CPU时间不友好
2. 惰性删除：仅在每次从键空间获取键是，都检查键是否过期，如果过期，就删除
对CPU时间友好，但对内存不友好
3. 定期删除：每隔一段时间，程序对数据库进行一次检查，删除里面的过期键
折中，但是难以确定操作的时长和频率

#### 9.6 Redis的过期键删除策略
Redis实际使用的是惰性删除和定期删除两种策略

##### 9.6.1 惰性删除策略的实现
由`db.c/expireIfNeeded`函数实现，所有读写数据库的命令在执行之前都会调用`expireIfNeeded`对输入键进行检查
+ 如果已过期，那么expireIfNeeded将输入建从数据库中删除
+ 如果未过期，该函数不做任何操作

##### 9.6.2 定期删除策略的实现
由`redis.c/activeExpireCycle`函数实现，每当redis的服务器周期性操作`redis.c/serverCron`函数执行时，`activeExpireCycle`函数就会被调用。
它在规定的时间内，分多次遍历各个数据库，从expire字段中*随机检查*一部分键的过期时间，并删除其中的过期键


#### 9.7 AOF、RDB和复制功能对过期键的处理

##### 9.7.1 生成RDB文件
执行`SAVE`命令或者`BGSAVE`命令创建一个新的RDB文件时，程序会对数据库中的键进行过期检查，已经过期的键不会被保存到RDB文件中

##### 9.7.2 载入RDB文件
在启动Redis时，如果开启了RDB功能，那么服务器会对RDB进行载入：
+ 服务器如果以主服务器模式运行，在载入RDB时，程序会对文件中保存的键进行过期检查，过期的键会被忽略
+ 如果是以聪服务器模式运行，无论是否过期，都会被载入到数据库，等到主从同步的时候，从服务器的过期键就会被情空

##### 9.7.3 AOF文件写入
当服务器以AOF持久化模式运行时，如果某个键已经过期，但是还没有被删除，那么AOF文件不会产生任何影响
当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令，来显式的删除这个键

##### 9.7.4 AOF重写
在AOF重写时，已过期的键不会被保存到重写后的AOF文件中

##### 9.7.5 复制
当服务器运行在复制模式下，从服务器的过期删除动作由主服务器来控制
+ 主服务器在删除一个过期键之后，会显式地向从服务器发送一个DEL命令，告知从服务器删除这个过期键
+ 从服务器在执行客户端发送的读命令时，即使碰到过期键，也不会将其删除
+ 从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键

#### 9.8 数据库通知
可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库命中的执行情况
获取0号数据库中针对message键执行的所有命令
```
SUBSCRIBE _ _keyspace@0_ _:message
```
这一类称为键空间通知；还有一类称为键时间通知，关注的是某个命令被什么键执行
```
SUBSCRIBE _ _keyevent@0_ _:del
```
获取0号数据库中所有执行DEL命令的键

##### 9.8.1 发送通知
由`notify.c/notifyKeyspaceEvent`函数实现
```
void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid);
```
type: 当前想要发送的通知类型，程序根据这个值来判断通知是否就是服务器配置notify-keyspace-events所选定的通知类型
event: 事件名称
key: 产生事件的键
dbid: 产生事件的数据库编号


### 第10章 RDB持久化

#### 10.1 RDB文件的创建与载入
+ SAVE：阻塞Redis服务器进程，直到RDB文件创建完毕，此期间服务器不能处理任何请求
+ BGSABE：派生出一个子进程，然后子进程去创建RDB，服务器进程继续处理命令请求

+ 如果服务器开启了AOF持久化，会优先采用AOF来还原数据库，因为AOF更新频率较高
+ 只有在AOF持久化关闭时，才会使用RDB文件来还原数据库

另外，BGRWREITEAOF和BGSAVE两个命令不能同时执行：
1. 如果BGSAVE正在执行，那么客户端发送的BGREWRITEAOF会被延迟到BGSAVE完成之后执行
2. 如果BGREWRITEAOF正在执行，那么客户端发送的BGSAVE会被服务器拒绝

服务器在载入RDB文件期间，是阻塞状态

#### 10.2 自动间隔性保存
可以使用save选项设置时多个保存条件，只要任一一个满足，服务器就会执行BGSAVE
```
save 900 1      // 900秒之内，对数据库进行了至少1次修改
save 300 10     // 300秒之内，至少10次修改
save 60 10000   // 60秒之内，至少10000次修改
```

##### 10.2.1 设置保存条件
Redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，reids服务器会默认如下选项：
```
save 900 1      // 900秒之内，对数据库进行了至少1次修改
save 300 10     // 300秒之内，至少10次修改
save 60 10000   // 60秒之内，至少10000次修改
```
接着，服务器会根据save所设置的保存条件，设置redisServer的saveparams属性
```
struct redisServer {
    // ..
    struct saveparams *saveparams;  // 记录保存条件的数组
    // ...
}
```

##### 10.2.2 dirty计数器和lastsave属性
除了saveparams数组，服务器还维持着一个dirty计数器，以及一个lastsave属性
```
struct redisServer {
    // ...
    long long dirty;    // 修改计数器：记录距离上一次成功SAVE或者BGSAVE命令之后，服务器对数据库修改的次数(写入、删除、更新)
    time_t lastsave;    // 上一次执行保存的时间: 记录上一次SAVE或BGSAVE的时间
}
```

##### 10.2.3 检查保存条件是否满足
Redis的服务器周期性操作函数serverCron函数每个100ms就会执行一次。对于正在运行的服务器进行维护，其中一项工作就是检查save选项所这是的保存条件是否已经满足.
伪代码如下：
```py
def serverCron():
    # ...
    for saveparams in server.saveparams:
        save_interval = unixtime_now() - server.lastsave
        if server.dirty >= saveparams.changes and save_interval > saveparam.seconds:
            BGSAVE()
    # ...
```

#### 10.3 RDB文件结构
1. REDIS: 5个字节，保存着"REDIS"5个字符
2. db_version: 4字节，保存了RDB的版本号
3. databases: 包含0个或任意多个数据库，以及各个数据库中的键值对数据
4. EOF常量: 1字节，标志着RDB文件正文内容结束
5. check_sum: 8字节无符号整数，保存一个校验和，对之前4个字段计算得出的，用于检查文件是否处所或者损坏

##### 10.3.1 database部分
每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分
1. SELECTDB: 常量，1字节，标志接下来读取的是数据库号码
2. db_number: 保存数据库号码，1、2或者5字节
3. key_value_pairs" 保存了数据库中所有键值对的数据，包括过期时间

##### 10.3.2 key_value_pairs部分
不带过期时间的键值对在RDB文件中由TYPE、key、value3部分组成；
带过期时间的键值对由EXPIRETIME_MS、ms、TYPE、key和value5部分组成。
其中：
    + EXPIRETIME_MS: 1字节，告知接下来读取的是一个ms为单位的过期时间
    + ms: 8字节的带符号整数
    
    
### 第11章 AOF持久化
AOF是通过保存Redis服务器所执行的写命令来记录数据库状态

#### 11.1 AOF持久化的实现
AOF的实现可以分为命令追加、文件写入、文件同步3个步骤

##### 11.1.1 命令追加
当AOF打开是，服务器在完成一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾
```
struct redisSever {
    // ...
    sds aof_buf;    // AOF缓冲区
    // ...
}
```

##### 11.1.2 文件写入和同步
Redis的服务器进程就是一个事件循环，循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复；
而时间事件负责执行类似serverCron函数这种需要定时运行的函数

服务器在执行文件事件时可能会执行写命令，使得一些内容被追加到了aof_buf缓冲区，所以，
服务器每次结束一个事件循环之前，都会调用`flushAppendOnlyFile`函数，考虑是否将aof_buf中的内容写入和保存到AOF文件里。
伪代码如下：
```py
def eventLoop():
    while True:
        proccessFileEvents()   # 处理文件事件
        processTimeEvents() # 处理时间事件
        flushAppendOnlyFile()   # 考虑是否将aof_buf内容写入并同步到AOF文件中
```

flushAppendOnlyFile函数会根据服务器配置的appendfsync选项来决定操作：
+ always：每个事件循环都会将aof_buf所有内容写入并同步到AOF文件，
+ everysec(默认): 每个事件循环将aof_buf所有内容写入到AOF文件，如果距离上次同步AOF文件的时间超过1秒，那么继续进行同步（由一个线程专门负责）
+ no: 每个事件循环将aof_buf所有内容写入到AOF文件，但不做同步，由操作系统控制

#### 11.2 AOF文件的载入和数据还原
Redis读取AOF文件并还原数据库状态步骤如下：
1. 创建一个不带网路连接的伪客户端：主要是因为Redis的命令只能在客户端上下文中执行
2. 从AOF文件中分析并读取一条写命令
3. 使用伪客户端执行这条命令
4. 重复2和3，知道AOF所有写命令被处理完毕

#### 11.3 AOF重写

##### 11.3.1 AOF文件重写的实现
AOF文件重写并不需要对现有AOF文件进行任何读取、分析或者写入，而是通过读取服务器当前的数据库状态来实现的

重写程序在处理列表、哈希表、集合、有序集合时，如果元素数量超过`redis.h/REIDS_AOF_REWRITE_ITEMS_PER_CMD`，那么重写程序会用多条记录来记录键的值，
避免造成客户端输入缓冲区溢出

##### 11.3.2 AOF后台重写
Redis服务器调用aof_rewrite函数时，由于Redis使用单个线程处理请求，所以服务器会长时间阻塞。所以redis将AOF重写放到了子进程中执行。这样做有2个目的：
1. 子进程执行AOF重写期间，父进程可以继续执行命令请求
2. 使用子进程而不是线程，子进程带有父进程的数据副本，可以在避免使用锁的情况下，保证数据的安全性

为了解决在AOF文件重写期间新的数据库状态变化，Redis设置了一个AOF重写缓冲区，这个缓冲区在服务器创建重写AOF子进程之后开始启用。当Redis服务器完成一个写命令之后，
它会同时将这个命令发送给AOF缓冲区和AOF重写缓冲区

在子进程完成AOF重写之后，会向父进程发送一个信号，父进程在接收到该信号之后，会调用信号处理函数，执行以下工作：
1. 将AOF重写缓冲区中的内容写入到新的AOF文件中
2. 原子的将这个新AOF文件覆盖现有的AOF文件


### 第12章 事件
Redis服务器是一个事件驱动程序，服务器主要处理一下两类事件：
1. 文件事件: Redis服务器通过套接字与客户端进行连接，而文件事件就是对套接字操作的抽象。服务器与客户端的通信会产生相应的文件事件，
服务器监听并处理这些事件来完成一系列网络通信操作
2. 时间事件：Redis服务器中一些操作，比如severCron函数，需要在给定的时间点执行，时间事件就是这类定时操作的抽象

#### 12.1 文件事件
Redis基于Reactor模式开发了自己的网络事件处理器——文件事件处理器
+ 使用IO多路复用来同时监听多个套接字，根据套接字目前执行的任务来为套接字关联不同的时间处理器
+ 当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作相对应的文件事件就会产生，这是文件事件处理器就会调用关联好的时间处理器来处理

虽然文件事件处理器以单线程的方式运行，但是使用IO多路浮盈实现了高性能

##### 12.1.1 文件事件处理器的构成
![avatar](/assets/images/redis_文件时间处理器组成.png)
IO多路复用程序将产生事件的套接字都放在一个队列里面，然后以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字。
文件事件分派器根据套接字产生的事件的类型，调用相应的事件处理器，也就是不同的函数

##### 12.1.2 I/O多路复用程序的实现
都是通过包装常见的select、epoll、evport和kqueue这些I\O多路复用函数库来实现的。

Redis为每个IO多路复用函数库都实现了相同的API，因此底层是可以互换的，编译时会自动选择性能最高的IO函数库来作为Reids中IO多路复用的底层实现

##### 12.1.3 事件的类型
IO多路复用程序可以监听多个套接字的`ae.h/AE_READABLE`和`ae.h/AE_WRITEABLE`事件：
+ 当套接字变得可读时（客户端对套接字执行了write操作，或者close), 或者有新的可应答套接字(客户端执行connect)时，套接字产生`AE_READBLE`事件
+ 当套接字变得可写时（客户端执行read操作），套接字产生`AE_WRITEABLE`事件

IO多路复用程序可以同时监听这两类事件，但是优先处理可读事件

##### 12.1.4 API
+ `ae,c\aeCreateFileEvent`: 接收一个套接字描述符、一个事件类型以及一个事件处理器作为参数，将给定套接字的给定事件加入到IO多路复用监听的范围之类
+ `ae.c\aeDeleteFileEvent`: 接收一个套接字描述符和一个监听事件类型作为参数，让IO多路复用取消对给定套接字的给定事件的监听
+ `ae.c\aeGetFileEvent`: 接收一个套接字描述，返回该套接字正在被监听的事件类型：
    + 如果没有任何事件被监听，返回`AE_NONE`
    + 如果套接字的读事件正在被监听，返回`AE_READABLE`
    + 如果写事件正在被监听，返回`AE_WRITABLE`
    + 读事件和写事件都在被监听，返回`AE_READABLE | AE_WRITEABLE`
+ `ae.c/aeWait`: 接收一个套接字描述符、一个事件类型和一个毫秒作为参数，在给定的时间内阻塞并等待套接字给定事件的发生
+ `ae.c/aeApiPoll`: 接收一个`sys/time.h/struct timeval`结构作为参数，并在指定的时间内，阻塞并等待所有被`aeCreateFileEvent`函数设置为监听状态的套接字产生文件事件
+ `ae.c/aeProccessEvents`: 文件事件分派器，先调用`aeApiPoll`来等待事件产生，然后遍历所有已产生的事件，并调用相应的事件处理器来处理
+ `ae.c/aeGetApiName`: 返回IO多路复用底层所使用的多路复用函数库的名称，比如"epoll"、"select"等

##### 12.1.5 文件事件的处理器
服务器最常用的文件事件处理器是与客户端进行通信的连接应答处理器、命令请求处理器和命令恢复处理器

+ 连接应答处理器：`networking.c\acceptTcpHandler`函数是Reids的连接应答处理器，用于对连接服务器监听套接字的客户端进行应答
当Redis初始化时，这个连接应答服务器会和服务器监听套接字的`AE_READABLE`事件关联起来，当有客户端使用`sys/socket.h/connect`函数连接服务器时，
套接字就会产生`AE_READBALE`事件，引发连接应答处理器执行
+ 命令请求处理器：`networking.c\readQueryFromClient`，负责从套接字中读入客户端发送的命令请求。
当一个客户端通过连接应答处理器成功连接到服务器之后，服务器将客户端的`AE_READBLE`事件和命令请求处理器关联起来，当客户端发送命令请求时，
套接字就长`AE_READBLE`事件，引发命令请求处理器执行；
客户端连接的整个过程中，服务器都会一直为客户端套接字的`AE_READABLE`事件关联命令请求处理器
+ 命令回复处理器：`networking.c\sendReplyToClient`，负责将执行命令后得到的命令恢复通过套接字返回给客户端
当服务器有命令回复需要传给客户端时，服务器会将客户端套接字的`AE_WRITEABLE`事件与命令回复处理器关联起来，
当客户端准备好接收服务器传回的回复时，就会产生`AE_WRITEABLE`事件，引发命令回复处理器执行。
命令回复发送完毕后，服务器就会解除回复处理器和客户端套接字`AE_WRITABLE`事件的关联

![avatar](/assets/images/redis_客户端和服务器的通信过程.png)

#### 12.2 时间事件
Redis的时间事件分为2类：
1. 定时事件
2. 周期性事件
目前版本Redis只是用了周期性事件


##### 12.2.1 实现
服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找已到达的时间事件，并调用相应的时间处理器。

##### 12.2.2 API
+ `ae.c/aeCreateTimeEvent`：接收一个毫秒数和一个时间事件处理器proc作为参数，将一个新的时间事件添加到服务器，这个新的时间事件会在当前时间的ms毫秒之后到达
+ `ae.c/aeDeleteFileEvent`: 接收一个时间事件ID作为参数，然后从服务器中删除该ID对应的时间事件
+ `ae.c/aeSearchNearestTimer`: 返回达到时间距离当前时间最近的一个时间事件
+ `ae.c/processTimeEvents`: 时间事件的执行器，这个函数会遍历所有已到达的时间事件，并调用这些事件的处理器

##### 12.2.3 时间事件应用实例: serverCron函数
serverCron主要工作包括：
+ 更新服务器的各类统计信息，比如时间、内存占用、数据库占用等
+ 清理数据库中的过期键值对
+ 关闭和清理失效的客户端
+ 尝试进行AOF或RDB持久化
+ 如果是主服务器，对从服务器定期同步
+ 如果处于集群模式，对集群进行定期同步和连接测试

Redis 2.8版本开始，用户可以修改`hz`选项来调整`serverCron`的每秒执行次数


#### 12.3 事件的调度与执行
因为服务器中同时存在文件事件和时间事件两种类型，所以服务器必须对这两类时间进行调度。
事件调度和执行由`ae.c/aeProccessEvents`函数负责，伪代码如下：
```py
def aeProcessEvents():
    # 获取到达时间最近的时间事件
    time_event= aeSearchNearestTimer()
    
    # 计算最近的还有多少毫秒
    remaind_ms = time_event.when - unix_ts_now()
    
    # 如果事件已经到达，那么remaind_ms可能为负数，将其设定为0
    if remaind_ms < 0:
        remaind_ms = 0
    
    # 根据remaind_ms的值，创建timeval结构
    timeval = create_timeval_with_ms(remaind_ms)
    
    # 阻塞并等待文件事件的产生，最大阻塞事件由传入的timeval结构决定
    # 如果remain_ms为0，那么aeApiPoll调用之后会马上返回，不阻塞
    aeApiPoll(timeval)
    
    # 处理所有已产生的文件事件 (和aeApiPoll一样，都是在aeProccessEvents函数中实现）
    proccessFileEvents()
    
    # 处理所有已到达的时间事件
    processTimeEvents()
```

将`aeProccessEvent`放在循环里，加上初始化和清理函数，这就构成了Redis服务器的主函数：
```py
def main():
    # 初始化服务器
    init_server()
    
    # 事件处理
    while server_is_not_shutdown():
        aeProcessEvents()
    
    # 服务器关闭，清理
    clean_server()
```

### 第13章 客户端
每个与服务器进行连接的客户端，服务器都为客户端建立了相应的`redis.h/redisClient`结构，保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构，包括
+ 客户端的套接字描述符
+ 客户端的名称
+ 客户端的标志值
+ 指向客户端正在使用的数据库的指针、以及该数据库的号码
+ 客户端当前要执行的命令、参数、参数的个数，以及指向命令实现函数的指针
+ 客户端的输入缓冲区和输出缓冲区
+ 客户端的复制状态信息，以及进行复制所需的数据结构
+ 客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构
+ 客户端的事务状态，以及执行WATCH命令用到的数据结构
+ 客户端执行发布与订阅功能时用到的数据结构
+ 客户端的身份验证标志
+ 客户端的创建时间、最后一次通信时间、客户端的输出缓冲区大小超出软性限制的时间

Redis服务器状态结构的clients属性是一个列表，保存了所有与服务器连接的客户端的状态结构
```
struct redisServer {
    // ...
    list *clients;  // 一个保存了所有客户端状态的链表
    // ...
}
```

##### 13.1 客户端属性
客户端的属性可以分为2类：
+ 通用属性，很少与特定功能相关
+ 和特定功能相关的属性，比如操作数据库时需要用到的db属性和dictid属性；执行事务时需要的mstate属性，以及执行WATCH时需要用到的watched_keys属性等

###### 13.1.1 套接字描述符
```
typedef struct redisClient {
     // ...
     int fd;
     // ...
} redisClient;
```
+ 伪客户端: fd = -1。伪客户端处理的命令请求来源于AOF文件或者LUA脚本，而不是网络，这种客户端不需要网络
+ 普通客户端：fd > -1的整数。

##### 13.1.2 客户端名称
一般是没有名字的，可以使用`CLIENT setname`为客户端设置一个名字，记录在redisClient的name属性里
```
typedef struct redisClient {
    // ...
    robj *name;
    // ...
} redisClient;
```

##### 13.1.3 标志
记录了客户端的角色，以及客户端目前所处的状态
```
typedef struct redisClient {
    // ...
    int flags;
    // ...
} redisClient;
```

##### 13.1.4 输入缓冲区
用于保存客户端发送的命令请求
```
typedef struct redisClient {
    // ...
    sds querybuf;
    // ...
} redisClient;
```
输入缓冲区会根据输入内容动态缩小或扩大，最大不超过1GB，否则会被关闭

##### 13.1.5 命令与命令参数
服务器会对命令请求的内容进行分析，并将得出的命令参数和参数个数保存到客户端状态的argv属性和argc属性
```
typedef struct redisClient {
    // ...
    robj **argv;
    int argc;
    // ...
} redisClient;
```
argv是一个数组，数组每一项是一个字符串对象，argv[0]是要执行的命令，之后的都是参数

##### 13.1.6 命令的实现函数
当服务器分析得出argv和args属性之后，服务器根据argv[0]的值，在命令表中查找对应的命令实现函数。
```
typedef struct redisClient {
    // ...
    struct redisCommand *cmd;
    // ...
} redisClient;
```
![avatar](/assets/images/redis_命令表.png)


##### 13.1.7 输出缓冲区
执行命令所得到的命令恢复会被保存在客户端的输出缓冲区里，每个客户端有2个输出缓冲区可用，一个是固定大小的，一个是可变大小的
+ 固定大小缓冲区：用于保存长度较小的恢复，比如OK，简短的字符串值，整数值，错误回复等
+ 可变大小缓冲区：保存长度较大的回复，比如非常长的字符串值，很多项的列表，很多元素的集合等
```
typedef struct redisClient {
    // ...
    char buf[REDIS_REPLY_CHUNK_BYTES];  // 默认16KB的固定大小缓冲区
    int bufpos; // 记录了buf数组已经使用的字节数量
    
    list *reply;    // 用链表来连接多个字符串对象，不必受到16KB的限制
    // ...
} redisClient;
```

##### 13.1.8 身份验证
记录客户端是否通过了身份验证
```
typedef struct redisClient {
    // ...
    int authenticated;  // 0-未通过验证 1-已通过验证
    // ...
} redisClient;
```

##### 13.1.9 时间
客户端有几个和时间有关的属性：
```
typedef struct redisClient {
    // ...
    time_t ctime;       // 创建客户端的时间
    time_t lastinteraction; // 客户端与服务器最后一次互动的时间
    time_t obuf_soft_limit_reached_time;    // 记录了输出缓冲区到第一次到达软性限制的时间
    // ...
} redisClient;
```

#### 13.2 客户端的创建与关闭

##### 13.2.1 创建普通客户端
客户端调用connect函数连接到服务器时，服务器调用连接事件处理器为客户端创建相应的客户端状态，并将这个心的客户端状态添加到clients链表的表尾

##### 13.2.2 关闭普通客户端
一个普客户端可能由于多种原因被关闭：
1. 客户端进程退出或被杀死
2. 客户端向服务器发送了带有不符合协议格式的命令请求，也会被关闭
3. 如果客户端成为了CLIENT KILL的目标，那它也会被关闭
4. 如果用户为服务器设置了timeout配置选项，那么当客户端的空转时间超过timeout值时，客户端将被关闭，但有例外
5. 如果客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认1GB），那么会被服务器关闭
6. 如果发送给客户端的命令恢复的大小超出了输出缓冲区的限制大小，那么会被服务器关闭

输出缓冲区的可变大小缓冲区由一个链表和任意多个字符串对象组成，理论上可以保存任意长的命令回复，但是为了避免占用过多资源，服务器会做相应的限制措施。
有两种模式：
1. 硬性限制：如果输出缓冲区超出了硬性限制的大小，服务器会立即关闭客户端
2. 软性限制：如果超出了软性限制的大小，但没超过硬性限制，那么服务器将用`obuf_sort_limit_reached_time`记录下客户端达到软性限制的开始时间，
之后服务器将继续监视客户端，如果缓冲区大小一直超出软性限制，并且持续时间超过服务器设定的市场，那么关闭客户端；如果在指定时间内代销不再超出软性限制，那么`obuf_sort_limit_reached_time`
也会被清0

使用`client-output-buffer-limit`可以为普通客户端、从服务器客户端、执行发布与订阅的客户端设置不同的软性和硬性限制
```
client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
```

##### 13.2.3 Lua脚本的伪客户端
略

##### 13.2.4 AOF文件的伪客户端
服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，载入完成后关闭这个客户端


### 第14章 服务器

#### 14.1 命令请求的执行过程
以`SET KEY VALUE`为例，在客户端发送这个命令到获得回复"OK"的期间，客户端和服务器共需要执行以下操作：
1. 客户端向服务器发送命令请求`SET KEY VALUE`
2. 服务器接收并处理客户端发来的请求，在数据库中进行操作，产生命令回复"OK"
3. 服务器将命令回复"OK"发送给客户端
4. 客户端接收命令回复，打印

##### 14.1.1 发送命令请求
用户在客户端键入命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器

##### 14.1.2 读取命令请求
当客户端与服务器的套接字变得可读时，服务器调用命令请求处理器来执行以下操作：
1. 读取套接字中协议格式的命令请求，将其保存的客户端状态的输入缓冲区中
2. 对输入缓冲区中的命令进行分析，提取出命令请求中包含的命令参数，参数个数，分别保存到argv属性和argc属性中
3. 调用命令执行器，执行客户端指定的命令

##### 14.1.3 命令执行器(1)：查找命令实现
命令执行器根据客户端状态的`argv[0]`参数，在命令表中查找所指定的命令，并将找到的命令保存到客户端状态的cmd属性中 

命令表是一个字典，键是命令名字，比如"set", "get", "del"等，而值是`redisCommand`结构，每个`redisCommand`结构记录了一个Redis命令的实现信息

以SET为例子，redisCommand结构属性如下：
+ SET的名字为"set"；实现函数为`setCommand`； 命令参数为-3，表示接受3个或3个以上的参数；命令标识为"wm", 表示SET是一个写入命令，并且在执行之前需要对内存状况进行检查；
+ GET的名字为"get"; 实现函数为`getCommand`;  命令参数为2，表示只接受2个参数；命令标识为"r", 表示是一个只读命令

##### 14.1.4 命令执行器(2): 执行预备操作
服务器已经将执行命令必须的命令实现函数、参数、参数个数收集完成，但是在正在的执行之前，程序还需要一些预备操作，包括：
1. 检查客户端状态的cmd指针是否指向NULL，如果是，说明用户输入的命令找不到对应的命令实现，服务器不再执行，返回错误
2. 根据客户端cmd指向的redisCommand结构的`arity`属性，检查命令请求给的参数个数是否正确，如果不正确，返回错误
3. 检查客户端是否通过了身份认证，未通过身份验证的客户端智能执行AUTH命令，否则返回错误
4. 如果服务器打开了maxmemory功能，在执行命令之前，会检查服务器的内存占用情况，并在有需要时进行内存回收
5. 如果服务器上一次执行BGSAVE时出错，并且服务器打开了`stop-writes-on-bgsave-error`功能，而且即将要执行的是一个写命令，服务器拒绝执行，返回错误
6. 如果客户端当前正在使用SUBSCRIBE订阅频道，或者正在用PSUBSCRIBE命令订阅模式，那么服务器只会执行客户端发来的SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE命令，
其他的都会被拒绝
7. 如果服务器正在进行数据载入，那么客户端发送的命令必须带有l标识（redisCommand的sflags属性）才会被执行
8. 如果服务器因为执行Lua脚本而超时并陷入阻塞，那么服务器只会执行客户端发来的SHUTDOWN nosave命令和SCRIPT KILL命令
9. 如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数发送给监视器
然后，服务器开始真正的执行命令

##### 14.1.5 命令执行器(3): 调用命令的实现函数
执行以下语句：
```
client->cmd->proc(client);
```
被调用的命令实现函数会执行指定的操作，并产生相应的回复，回复会被保存在客户端状态的buf属性和reply属性中，之后实现函数还会为客户端的套接字关联命令回复处理器，将回复返回给客户端

##### 14.1.6 命令执行器(4): 执行后续工作
执行完实现函数之后，还需要执行一些后续工作：
1. 如果服务器开启了慢查询日志功能，那么会检查是否需要为刚才的命令请求添加一条慢查询日志
2. 根据刚刚执行的命令所耗费的市场，更新被执行命令的redisCommand结构的milliseconds属性，并且将calls计数器+1
3. 如果开启了AOF，那么会将刚刚执行的命令请求写入AOF缓冲区中
4. 如果有其他从服务器正在复制当前这个服务器，会将刚刚执行的命令传播给所有从服务器

##### 14.1.7 将命令回复发送给客户端
当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在输出缓冲区的命令回复发送给客户端

#### 14.2 serverCron函数
redis的serverCron函数每隔100ms执行一次，负责管理服务器的资源。下面是serverCon函数执行操作的完整介绍：

##### 14.2.1 更新服务器时间缓存
unixtime和mstime用作当前时间的缓存，减少系统调用的执行次数
```
struct redisServer {
    // ...
    time_t unixtime;    // 秒级别的当前UNIX时间戳
    long long mstime;   // 毫秒级别的当前UNIX时间戳
    // ...
}
```
对于键的过期时间、慢查询日志等需要高精度时间的功能来说，服务器还是会执行系统调用来获取最准确的当前系统时间

##### 14.2.2 更新LRU时钟
```
struct redisServer {
    // ...
    unsigned lruclock:22;   // 默认每10s更新一次的时钟缓存，用于计算键的空转时长
    // ...
}
```
每个redis对象有一个lru属性，保存了对象最后一次被命令访问的时间。
程序会用服务器的lruclock - 对象的lru 来得出空转时间

##### 14.2.3 更新服务器每秒执行命令次数
serverCron函数中的`trackOperationsPerSecond`函数会以每100ms一次的频率执行，以抽样计算的方式，估算服务器在最近一秒处理的命令请求数量，可以通过`INFO status`的
`instantaneous_ops_per_sec`查看

##### 14.2.4 更新服务器内存峰值记录
`stat_peak_memory`记录了服务器内存峰值大小：
```
struct redisServer {
    // ...
    size_t stat_peak_memory;    // 已使用内存峰值
    // ...
}
```
使用INFO memory命令查看

##### 14.2.5 处理SIGTERM信号
服务器启动时，Redis会为服务器进程的SIGTERM信号关联处理器`sigtermHandler`函数，这个信号处理器负责在服务器接收到SIGNTERM信号时，打开服务器状态的`shutdown_asap`标识
```
static void sigtermHandler(int sig) {
    // 打印日志
    redisLogFromHandler(REDIS_WARNING, "Received SIGTERM, scheduling shutdown...");
    // 打开关闭标识
    server.shutdown_asap = 1;
}
```
每次serverCron函数运行时，程序都会对服务器状态的shutdown_asap进行检查，依次来决定是否关闭服务器。
服务器在关闭自身之前会进行RDB持久化操作等

##### 14.2.6 管理客户端资源
serverCron函数每次都会调用`clientsCron`函数，`clientsCron`函数会对一定数量的客户端进行以下2项检查：
1. 如果客户端与服务器之间的连接已经超时，释放这个客户端
2. 如果客户端在上次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区

##### 14.2.7 管理数据库资源
serverCron函数每次都会调用`databaseCron`函数，这个函数会对一部分数据库进行检查：删除其中的过期键，并在有需要时，对字典进行收缩操作

##### 14.2.8 执行被延迟的BGREWRITEAOF
在服务器执行BGSAVE期间，如果客户端发来BGREWRITEAOF命令，这个命令会被延迟到BGSAVE执行完成之后。服务器的`aof_rewrite_scheduled`标识记录服务器是否延迟了BGREWRITEAOF
```
struct redisServer {
    // ...
    int aof_rewrite_scheduled;  // 1——有BGREWRITEAOF被延迟了
    // ...
}
```

##### 14.2.9 检查持久化操作的运行状态
服务器状态使用`rdb_child_pid`属性和`aof_child_pid`属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID，这2个属性也可以用来检查BGSAVE或者BGREWRITEAOF命令是否正在执行

serverCron函数每次都会检查`rdb_child_pid`和`aof_child_pid`，只要其中一个属性的值不为-1，程序就会执行一次`wait3`函数，检查子进程是否有信号发来服务器进程：
+ 如果有信号到达，表示新的RDB文件已经生成或者AOF文件已经重写完毕，服务器需要进行相应命令的后续收尾操作，替换新的RDB文件或者AOF文件
+ 如果没有信号，表示持久化操作未完成，不做任何动作

另外，如果`rdb_child_pid`和`aof_child_pid`都是-1，那么说明此时没有任何持久化操作在执行，程序执行以下3个检查：
1. 查案是否有BGREWRITEAOF被延迟了，如果有，开始一次新的BGREWRITEAOF操作
2. 检查服务器的自动保存条件是否被满足，如果满足，开始一次新的BGSAVE操作
3. 检查服务器设置的AOF重写条件是否满足，如果满足，开始一次新的BGREWRITEAOF操作

##### 14.2.10 将AOF缓冲区的内容写入AOF文件
如果服务器开启了AOF持久化，并且AOF缓冲区中还有待写入的数据，那么serverCron函数会调用相应的程序将缓冲区中内容写入AOF文件

##### 14.2.11 关闭异步客户端
关闭那些输出缓冲区超过限制的客户端

##### 14.2.12 增加cronloops计数器
每执行一次serverCron函数，就为cronloops计数器+1， 这个计数器的唯一作用就是实现"每执行serverCron函数N次就执行1次指定代码"的功能

#### 14.3 初始化服务器
一个Redis服务器需要经过一系列的初始化和设置过程，才能够接受客户端的命令请求，比如初始化服务器状态、接受用户指定的服务器配置、创建相应的数据结构和网络连接等

##### 14.3.1 初始化服务器状态结构
创建一个`struct redisServer`类型的实例变量`server`作为服务器状态，并未结构中的各个属性赋默认值，由`redis.c\initServerConfig`函数完成
```
void initServerConfig(void) {
    // 设置服务器的运行id
    getRandomHexChars(server.runid, REDIS_RUN_ID_SIZE);
    
    // 为运行id加上结尾字符
    server.runid[REDIS_RUN_ID_SIZE] = '\0';
    
    // 设置默认配置文件路径
    server.configfile = NULL;
    
    // 设置默认服务器频率
    server.hz = REDIS_DEFAULT_HZ;
    
    // 设置服务器的运行架构
    server.arch_bits = (sizeof(long) == 8) ? 64 : 32;
    
    // 设置默认端口号
    server.port = REDIS_SERVERPORT;
    
    // ...
}
```
主要工作分别是：
+ 设置服务器的运行ID
+ 设置默认运行频率
+ 设置默认配置文件路径
+ 设置运行架构
+ 设置默认端口号
+ 设置默认RDB持久化条件和AOF持久化条件
+ 初始化服务器的LRU时钟
+ 创建命令表

当`initServerConfig`执行完成后，服务器进入初始化第2个阶段——载入配置项

##### 14.3.2 载入配置选项
比如`redis-server redis.conf`, 其中
```
# 数据库数量设置为32个
database 32

# 关闭RDB文件压缩功能
rdbcompression no
```
在启动时的配置选项会覆盖掉默认的选项。

##### 14.3.3 初始化服务器数据结构
在执行`initServerConfig`函数初始化server状态时，程序只创建了命令表一个数据结构。然后开始初始化其他的数据结构，包括：
+ server.clients链表
+ server.db数组
+ 保存频道订阅信息的server.pubsub_channels字典，保存模式订阅信息的server.pubsub_patterns链表
+ 用于执行Lua脚本的Lua环境server.lua
+ 用于保存慢日志查询的server.slowlog
这些数据结构，都会在`initServer`函数中分配内存。除了初始化这些数据结构之外，还进行了一些重要操作，包括：
+ 为服务器设置进程信号处理器
+ 创建共享对象：包括Redis服务器经常用到的值，比如"OK"的字符串对象，1~10000的字符串对象等
+ 打开服务器的监听端口，为监听套接字关联连接应答事件处理器
+ 为serverCron函数创建时间事件，等待服务器正式运行时执行serverCron函数
+ 如果AOF持久化打开，那么打开现有的AOF文件，如果不存在，创建并打开一个新的AOF文件，为写入做好准备
+ 初始化服务器的后台I/O模块，为IO操作准备

##### 14.3.4 还原数据库状态
完成了server变量的初始化之后，需要载入RDB文件或者AOF文件来还原数据库
+ 如果启用了AOF，使用AOF来还原数据库
+ 如果没有，使用RDB文件来还原

##### 14.3.5 执行事件循环
开始执行服务器的时间循环，开始接受客户端的连接请求，处理命令请求


### 第18章 发布与订阅
由PUBLISH、SUBSCRIBE、PSUBSCRIBE等命令组成
```
SUBSCRIBE "news.it"

PUBLISH "news.it" "hello"
```
除了订阅频道外，还可以用PSUBSCRIBE订阅一个或多个模式：

![avatar](/assets/images/redis_频道和模式的订阅状态.png)

#### 18.1 频道的订阅与退订
Redis将所有的频道订阅关系保存在服务器状态的pubsub_channels字典里，键是某个被订阅的频道，值是一个链表，记录了所有订阅这个频道的客户端
```
struct redisServer {
    // ...
    dict *pubsub_channels; 
    // ...
}
```

##### 18.1.1 订阅频道
新订阅的客户端加载pubsub_channels对应频道的链表的表尾

##### 18.1.2 退订频道

#### 18.2 模式的订阅与退订
保存在服务器状态的pubsub_patterns里，pubsub_pattern是一个链表，链表每个节点都包含了一个pubsubPattern结构，其中的pattern属性记录了被订阅的模式，client记录了客户端
```
typedef struct pubsubPattern {
    redisClient *client;    // 订阅模式的客户端
    robj *pattern;          // 被订阅的模式
} pubsubPattern;
```


### 第19章 事务
Redis通过MULTI、EXEC、WATCH等命令实现事务。以MULTI开始，以EXEC结尾

#### 19.1 事务的实现
一个事务从开始到结束：
1. 事务开始
2. 命令入队
3. 事务执行

##### 19.1.1 事务开始
`redis> MULTI`, 切换至事务状态，通过客户端状态的flags属性打开REDIS_MULTI标识来实现的，即`client.flags |= REDIS_MULTI`

##### 19.1.2 命令入队
当客户端在事务状态下，服务器会根据客户端发来的不同命令执行不同操作：
+ 如果命令为EXEC、DISCARD、WATCH、MULTI其中一个，则立即执行
+ 除此之外的命令，并不立即执行，而是将命令放到一个事务队列，然后向客户端返回QUEUED回复

##### 19.1.3 事务队列
事务状态保存在客户端状态的mstate属性
```
typedef struct redisClient{
    // ...
    multiState mstate;  // 事务状态
    // ...
} redisClient;
```
事务状态包含一个事务队列，以及一个已经入队命令的计数器
```
typedef struct multiState {
    multiCmd *commands; // 事务队列，FIFO
    int count; 已入队命令计数
} multiState;
```
事务队列是一个multiCmd数组，每个multiCmd保存了一个入队命令的信息，包括实现函数的指针、命令参数、参数数量
```
typedef struct multiCmd {
    robj **argv;    // 参数
    int argc;       // 参数数量
    struct redisCommand *cmd;   // 命令指针
} multiCmd;
```

##### 19.1.4 执行事务
EXEC命令会被立即执行，服务器遍历这个客户端的事务队列，执行队列所保存的所有命令，最后将结果全部返回客户端

#### 19.2 WATCH命令的实现
WATCH命令是一个乐观锁，可以在EXEC之前执行，监视任意数量的键，检查被监视的键是否至少有一个被修改，如果是，服务器拒绝执行事务，返回执行失败

##### 19.2.1 使用WATCH监视数据库键
每个Reids数据库保存着一个watched_keys字典，键是某个被watch的数据库建，值是一个链表，链表记录了所有监视相应数据库键的客户端
```
typedef struct redisDb {
    // ...
    dict *watched_keys;
    // ...
} redisDb;
```

##### 19.2.2 监视机制的触发
所有对数据库进行修改的命令，在执行之后都会调用`multi.c/touchWatchKey`函数对`watched_keys`字典进行检查，看是否有客户端正在监视刚刚被修改的键，
如果有，那么touchWatchKey函数会将监视被修改键的客户端的`REDIS_DIRTY_CAS`标识打开，标识事务的安全性已经被破坏

##### 19.2.3 判断事务是否安全
当服务器收到一个客户端发来的EXEC时，服务器会根据这个客户端是否打开了`REDIS_DIRTY_CAS`标识来决定是否执行事务

#### 19.3 事务的ACID性质
原子性、一致性、隔离型、耐久性

Redis事务和传统关系型数据库的最大区别在于，Redis不支持事务回滚机制，即使事务队列中某一个命令出了错，整个事务也会执行下去，直到所有命令都被执行完毕


// todo: @2019-05-30
Redis 一致性哈希
多机数据库的实现