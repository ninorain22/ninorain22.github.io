## redis设计与实现

### 第2章 简单动态字符串
没有直接使用C语言传统字符串，而是自己构建了一种简单动态字符串SDS的抽象类型

举例如下：
```
redis> set msg "hello world"
```
那么Redis将在数据库中创建一个键值对，其中：
+ 键值对的键值是一个字符串对象，对象的底层实现是一个保存着字符串"msg"的SDS
+ 键值对的值也是一个字符串对象，底层实现是一个保存着字符串"hello world"的SDS

除了用了保存数据库中的字符串值之外，SDS还被用作缓冲区：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是SDS实现的

#### 2.1 SDS的定义
```
struct sdshdr {
    int len;    // 记录buf数组中已经使用的字节数，相当于SDS所保存的字符串的长度
    int free;   // 记录buf数组中未使用的字节数
    char buf[]; // 用于保存字符串
```

#### 2.2 SDS与C字符串的区别
C采用N+1的字符数组来表示长度N的字符串，但是不适合Redis

##### 2.2.1 常数复杂度获取字符串长度
C字符串获取长度的操作复杂度是O(N); 而SDS获取长度复杂度O(1).
这样确保了获取字符串长度不会成为Redis的性能瓶颈

##### 2.2.2 杜绝缓冲区溢出
C字符串不记录自身长度带来的另一个问题就是容易操作缓冲区溢出。
比如`char *strcat(char *dest, char *src);`函数中，如果没有给dest分配足够的内存，那么dest的数据将溢出到它响铃的空间中。

而SDS的空间分配策略杜绝了发生缓冲区溢出的可能，当需要对SDS修改时，会先检查SDS的空间是否满足修改所需，如果不满足，
会自动将SDS的空间扩展，然后再执行时间的修改。

##### 2.2.3 减少修改字符串时带来的内存重分配次数
C字符串的长度和底层数组的长度存在着关联性，所以每次增长或者缩短一个C字符串，程序都要对这个C字符串的数据进行一次内存重分配操作
+ 增长操作：在操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小，否则会产生缓冲区溢出
+ 缩短操作：在操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间，否则会产生内存泄露

Redis中，数据会被频繁修改，所以如果每次修改字符串的长度都要执行一次内存重分配的话，会对性能造成影响。
为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度的关联。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略
1. 空间预分配： 当SDS的API对一个SDS修改并且需要扩展时，程序不仅会为SDS分配修改所必须的空间，还会分配额外的未使用空间
    + 如果修改后，SDS的长度<1MB, 那么程序会分配和len属性同样大小的未使用空间
    + 如果修改后，SDS的长度>=1MB, 程序会分配1MB的未使用空间
2. 惰性空间释放：用于优化SDS字符串缩短操作，当SDS的API缩短SDS所保存的字符串时，程序不会立即使用内存重分配来回收缩短后不需要用到的字节，
而是使用free属性将这些字节数量记录起来，等待将来使用

##### 2.2.4 二进制安全
所有SDS的API都会以处理二进制的方式来处理SDS存放在buf数组里的数据

##### 2.2.5 兼容部分C字符串函数



### 第3章 链表
列表键的底层实现之一就是链表，当一个列表键包含了比较多的元素，或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为底层实现

#### 3.1 链表和链表节点的实现
```
typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;

typedef struct list {
    listNode *head;
    listNode *tail;
    unsigned long len;  // 链表所包含节点的数量
    void *(*dup)(void *ptr);    // 节点值复制函数
    void *(*free)(void *ptr);   // 节点值释放函数
    int (*match)(void *ptr, void *key); // 节点值对比函数
} list;
```


### 第4章 字典
Redis的数据库就是用字典来作为底层是实现。
当执行`set msg "hello world`时，会在数据库中创建一个键值为"msg", 值为"hello world"的键值对，这个键值对就保存在代表数据库的字典里

除了用来表示数据库，字典还是哈希键的底层实现之一，当一个哈希键包含的键值较多，或者键值对中都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现

#### 4.1 字典的实现
Redis的字典使用哈希表作为底层实现

##### 4.1.1 哈希表
```
typedef struct dictht {
    dictEntry **table;  // 哈希表数组
    unsigned long size; // 哈希表大小
    unsigned long sizemask; // 哈希表大小掩码，用于计算索引值，总是=size-1
    unsigned long used; // 哈希表已有节点数量
} dictht
```
table是一个dictEntry结构的指针数组，每个dictEntry保存着一个键值对。

##### 4.1.2 哈希表节点
哈希表节点就是dictEntry结构，每个保存着一个键值对
```
typedef struct dictEntry {
    void *key;  // 键
    union {     
        void *val;
        uint64_tu64;
        int64_ts64;
    } v;    // 值
    struct dictEntry *next; // 指向下个节点，形成链表
} dictEntry;
```
v是键值对的值，可以是一个指针，或者一个uint64_t整数，或者int64_t整数。
next是指向另一个哈希节点的指针，可以将多个哈希值相同的键值对连接在一起，解决键冲突问题

##### 4.1.3 字典
```
typedef struct dict {
    dictType *type; // 类型特定函数
    void *privdata; // 私有数据
    dictht ht[2];   // 哈希表
    int rehashidx; // rehash索引
} dict;
```
其中，type是一个dictType结构的指针，每个dictType保存了一簇用于操作特定类型键值对的函数，redis会为用途不同的字典设置不同的类型特定函数
```
typedef struct dictType {
    unsigned int (*hashFunction)(const void *key);  // 计算哈希值的函数
    void *(*keyDup)(void *privdata, const void *key);   // 复制键的函数
    void *(*valDup)(void *privdata, const void *obj);   // 复制值的函数
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);  // 对比键的函数
    void (*keyDestructor)(void *privdata, void *key);   // 销毁键的函数
    void (*valDestructor)(void *privdata, void *obj);   // 销毁值的函数
} dictType;
```
+ ht: 一般只用ht[0]哈希表，ht[1]只在rehash的时候使用
+ trehashidx: 记录了rehash的进度，如果当前没有rehash在进行，就是-1


#### 4.2 哈希算法
要将一个新的键值对添加到字典里面，程序先要根据键值计算出哈希值和索引值，然后在根据索引值，将包含这个键值对的哈希表节点放到哈希表数组指定的索引上。
```
// 计算key的哈希值
hash = dict->type->hashFunction(key);
// 根据哈希表的sizemask和哈希值，计算出索引值
index = hash * dict->ht[x].sizemask;    // x可以是0或1
```

当字典被用作数据库底层， 或者哈希键的底层实现时，redis使用MurmurHash2算法来计算哈希值


#### 4.3 解决键冲突
redis采用链地址法来解决键冲突。然后放在最前面

#### 4.4 rehash
为了让负载因子维持在一个合理范围之内，当哈希表保存的键值对数据太多或者太少的时候，程序需要对哈希表的大小相应的扩展或者收缩。

redis对字典的哈希表执行rehash的步骤如下:
1. 为字典的ht[1]哈希表分配空间，大小取决于要执行的操作，以及ht[0]当前包含的键值对的数量
    + 如果是扩展操作，那么ht[1]的大小为**第一个大于等于ht[0].used*2的2的n次方幂**
    + 如果是收缩操作，ht[1]的大小为第一个大于等于ht[0].used的2的n次方幂
2. 将保存在ht[0]中的所有键值对rehash到ht[1]
3. 当ht[0]全部都rehash到ht[1]上后，释放ht[0], 将ht[1]设置为ht[0], 并在ht[1]上新建一个空白哈希表，为下一次rehash准备

##### 何时扩展和收缩
当以下任意一个条件满足时，程序会自动对哈希表执行扩展操作
1. 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表负载因子>=1
2. 服务器正在执行BGSAVE命令或者BGREWRITEAOF命令，并且负载因子>=5

负载因子: `load_factor = ht[0].used / ht[0].size`

另外，当负载因子<0.1时，程序自动对哈希表执行收缩操作

#### 4.5 渐进式rehash
服务器是分批次的，渐进的将ht[0]里的键值对rehash到ht[1]的。
1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表
2. 在字典中维持着一个索引计数器rehashidx, 设置为0
3. 在rehash期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作之外，还会顺带将ht[0]表在rehashidx索引上的所有键值对
rehash到ht[1], 然后将rehashidx增1
4. 随着字典操作不断进行，最终ht[0]的值都会被rehash到ht[1], 然后将rehashidx设置为-1，表示rehash完成

在rehash过程中，查找会先在ht[0]里，如果没找到，再去ht[1], 而新添加的键值对只会添加在ht[1]上。


### 第5章 跳跃表
跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问

redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，或者有序集合中元素的成员都是比较长的字符串时，
Redis会采用跳跃表来作为底层实现。

Redis只在2个地方用到了跳跃表，一个是有序集合键，另一个是在集群节点中用作内部数据结构。

#### 5.1 跳跃表的实现
zskiplist结构: 跳跃表节点相关信息
+ header: 跳跃表表头节点
+ tail: 跳跃表表尾节点
+ level: 跳跃表内最大的层数(表头节点不算在内)
+ length: 记录跳跃表长度(表头节点不算在内)

zskiplistNode结构: 跳跃表节点
+ level: 层，用L1，L2,L3,L4标记节点的各个层，每个层都有2个属性: 前进指针和跨度
    + 前进指针：用于访问位于表尾方向的其他节点
    + 跨度：记录前进指针所指向的节点和当前节点的距离
+ backward: 后退指针，用BW标记的后退指针，指向位于当前节点的前一个节点
+ score: 分值，跳跃表中，节点按各自所保存的分值从小到大排列
+ obj: 成员对象，各个节点中所保存的成员对象

##### 5.1.1 跳跃表节点
```
typedef struct zskiplistNode {
    // 层
    struct zskiplistLevel {
        struct zskiplistNode *forward;  // 前进指针
        unsigned int span;  // 跨度
    } level[];
    
    struct zskiplistNode *backward; // 后退指针
    double score;   // 分值
    robj *obj;  // 成员对象
} zskiplistNode;
```
1. 层：跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，可以通过这些层来加快访问其他节点的速度。
每次创建一个新的跳跃表节点时，程序会根据幂次定律，随机生成一个1~32之间的值作为level数组的大小，这个大小就是层的高度
2. 前进指针：每一层都有一个指向表尾方向的前进指针`level[i].forward`
3. 跨度：层的跨度`level[i].span`，用于记录两个节点之间的距离。用来计算rank的：在查找某个节点过程中，将沿途访问过的所有层的跨度累计起来，就是目标节点在跳跃表中的rank
4. 后退指针：方便从表尾向表头遍历跳跃表的节点
5. 分值和成员：分值是一个double型，所有节点都按照分值从小到大排序；节点的成员对象是一个指针，指向一个字符串独享，字符串独享保存着一个SDS值

##### 5.1.2 跳跃表
使用一个zskiplist结构来管理持有这些跳跃表节点，就可以方便的对整个跳跃表进行处理
```
typedef struct zskiplist {
    struct zskiplistNode *header, *tail;    // 表头、表尾节点
    unsigned long length;   // 表中节点数量
    int level;  // 最大的节点层数
} zskiplist;
```


### 第6章 整数集合
如果一个集合只包含整数值元素，并且数量不多，Redis就会使用整数集合做为集合键的底层实现

#### 6.1 整数集合的实现
整数集合是Redis保存整数值的集合的抽象数据结构，可以保存类型为`int16_t`, `int32_t`, `int64_t`类型的整数，并且不会重复
```
typedef struct intset {
    uint32_t encoding;  // 编码方式
    uint32_t length;    // 元素数量
    int8_t contents[];  // 保存元素的数组
} intset;
```
+ contents: 整数几个的每个元素都是contents数组中的一项，各个项按照值的大小从小到大排序，并且不包含任何重复项
+ length: contents的长度

#### 6.2 升级
如果将一个新元素添加到整数集合里，并且新元素的类型比现有所有的类型都要长，那么整数集合就需要先进行升级，才能将新元素添加进来

升级并添加新元素共分为3步：
1. 根据新元素的类型，扩展整数集合底层数据的空间大小，并为新元素分配空间
2. 将底层所有元素都转成与新元素相同的类型，然后放到正确的位置上，维持底层数据有序性
3. 添加新元素到底层数组

整数集合不支持降级操作。


### 第7章 压缩列表
压缩列表ziplist是列表键和哈希键的底层实现之一。
当一个列表项只包含少量项，并且每个项要么就是小整数值，或者是比较短的字符串，那么redis就会使用压缩列表来作为列表键的底层实现；
当一个哈希键值包含少量键值对，并且每个键值对的键和值要么是小整数或者比较短的字符串，那么redis也会使用压缩列表来实现哈希键

#### 7.1 压缩列表的构成
为了节约内存而开发，由一系列特殊编码的连续内存块组成的额顺序型数据结构，一个压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者一个整数
+ zlbytes: 4字节，用于记录整个压缩列表占用的内存字节数
+ zltail: 4字节，用于记录压缩列表表尾节点距离压缩列表的起始地址有多少字节
+ zllen: 2字节，用于记录压缩列表包含的节点数量
+ entryX: 不定，压缩列表的各个节点，节点的长度由节点保存的内容决定
+ zlend: 1字节，0xFF, 用于标记压缩列表末端

#### 7.2 压缩列表节点的构成
每个节点可以保存一个字节数组或一个整数，其中，字节数组可以是以下三种长度：
+ 长度<=2^6-1字节的字节数组
+ 长度<=2^14-1字节的字节数组
+ 长度<=2^32-1字节的字节数组
整数可以是以下6种长度
+ 4位长，0~12之间的无符号整数
+ 1字节长的有符号整数
+ 3字节长的有符号整数
+ int16_t类型整数
+ int32_t类型整数
+ int64_t类型整数

每个压缩列表节点都由三个部分组成：
1. previous_entry_length: 记录压缩列表中前一个节点的长度，以字节为单位。
如果前一个节点长度<254, 那么这个字段长度就是1字节；如果前一个节点长度>=254字节，那么这个字段长度就是5字节，其中第一字节会被设置为0xFE.
程序可以根据通过指针运算，根据当前节点起始地址来计算出前一个节点的起始地址
2. encoding: 记录了节点的content属性所保存的数据的类型以及长度
    + 一字节、两字节或者5字节长，最高位为00，01或者10是字节数组编码，表示content属性保存着字节数组，数组的长度由这2位之后的其他位记录
    + 一字节长，最高位11开头，表示content保存着整数值，整数的类型和长度由其他位记录
3. content: 可以是一个字节数组或者整数，由encoding字段决定

#### 7.3 连锁更新
在添加新节点和删除节点时，都可能会引发连锁更新。最坏情况下需要执行N次空间重分配操作，每次分配空间最坏复杂度是O(N), 所以连锁更新最坏复杂度是O(N^2)

但是真正造成的性能问题的几率很低，可以忽略。


### 第8章 对象
前几章介绍了Redis用到的主要数据结构。但是Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统。
这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这5个类型

Redis使用对象的好处：
1. Redis在执行命令前，根据对象的类型来判断一个对象是否可用执行给定的命令
2. 根据不同场景选取不同的数据结构，优化使用效率
3. Redis对象系统还实现了基于引用计数的内存回收机制
4. 通过引用计数实现了对象共享机制，通过多个数据库建共享同一个对象来节约内存
5. Redis的对象带有访问时间记录信息，可用于计算数据库键的空转市场，在启用了maxmemory功能下，空转时间较大的键可能会被优先删除

#### 8.1 对象的类型和编码
每次在Redis创建一个键值对时，都至少会创建2个对象，一个是键对象，一个是值对象。
Redis中每个对象都由一个redisObject结构表示
```
typedef struct redisObject {
    unsigned type:4;    // 类型
    unsigned encoding:4;    // 编码
    void *ptr;  // 指向底层实现的数据结构的指针
    //...
} robj;
```

##### 8.1.1 类型
1. REDIS_STRING: 字符串
2. REDIS_LIST: 列表对象
3. REDIS_HASH: 哈希对象
4. REDIS_SET: 集合对象
5. REDIS_ZSET: 有序集合对象

对于键值来说，总是一个字符串对象，而值就可以是任一种对象。

##### 8.1.2 编码和底层实现
ptr指向对象的底层实现数据结构，这些数据结构由对象的encoding属性决定
1. REDIS_ENCODING_INT: long类型整数
2. REDIS_ENCODING_EMBSTR: embstr编码的简单动态字符串
3. REDIS_ENCODING_RAW: 简单动态字符串
4. REDIS_ENCODING_HT: 字典
5. REDIS_ENCODING_LINKEDLIST: 双端链表
6. REDIS_ENCODING_ZIPLIST: 压缩列表
7. REDIS_ENCODING_INTSET: 整数集合
8. REDIS_ENCODING_SKIPLIST: 跳跃表和字典


#### 8.2 字符串对象

