一面，电话面试，面试官自我介绍是口碑的。

先让做自我介绍，这个不表。他手上应该有我猎聘网的简历。直接拿项目开问

#### Q1: 我看你在这家公司是负责购物车、订单这些模块的。那简单说下你们订单系统的流程。
A1: 
前端（H5／APP）发起订单创建申请，先落地这笔申请，然后分别入队：
1. 订单创建队列
2. 10分钟的订单下单状态纠错队列

分别用于
1. 处理下单逻辑，比如锁优惠券，锁库存等
3. 处理意外导致的订单最终状态不一致

如果一切OK，修改订单创建申请的状态，生成一条代付款订单记录，并且入队一条信息到订单超时未支付队列，用于在1小时后，用户仍然未付款，回复库存、优惠券等资源

前端在下完单后轮询订单创建申请状态，如果通过，就可以继续下一步操作，比如支付等。
支付完成以后，因为我们是做跨境电商，为了方便用户，我们会把这个订单buffer住3小时，方便3小时内用户取消订单。否则该笔订单推送至海关后，取消就比较麻烦

大致是这样

#### Q2: 下单流程中，你们如何处理锁优惠券，锁库存？
A2:
在异步下单处理中，分别调用各个子模块，并且记录已调用的模块。当某一个子模块同步操作失败（比如锁优惠券失败）时，分别调用已经调用过模块的回滚操作。
需要各个子模块配合订单系统的设计，提供锁定接口和回滚接口

#### Q3: 你是如何记录这些已经调用的模块？放在DB还是内存？
A3:
放内存

#### Q4: 如果这个时候内存丢失了，这笔订单如何处理？
A4:
之前说的10分钟下单状态纠错队列可以来处理这种问题。如果内存丢失，10分钟后，系统会判断该笔订单是否下单成功，如果没有，依此回滚可能调用到的所有业务

#### Q5: 能否这里再做优化？仅仅回滚调用过的模块。因为对于阿里这种流量巨大的系统，不必要的流程是要被优化掉的
A5:
那可以在每次调用一个模块后，插一条消息到队列，异步写入DB。这样，就算内存丢失，10分钟后的订单纠错仅需回滚DB里存在的模块

#### Q6: 说到锁，你知道乐观锁和悲观锁吗？
A6:
悲观锁就是拿数据前，会认为任何人都可能改变这个数据，因此需要进入之前加锁，操作完成后释放，比如一些数据库的行锁，表锁
乐观锁就是相反，会认为没有人会改变这个数据，拿数据的时候不上锁，写的时候再判断是否被其他人改变

#### Q7: 你说行锁和表锁，那什么情况下会出发行锁和表锁？
A7:
Mysql InnoDB里update一条记录会出发行锁。表锁的话，确实不清楚什么时候会触发，只知道显式的lock table会表锁

#### Q8: 之前听你说到锁库存，根据什么锁？如果有这样一种需求，类似于抢购，你会如何实现？
A8: 
根据订单code锁库存，库存系统保证幂等性。
如果是抢购，直接操作DB可能不太合适，可以在抢购开始前，将DB的数据同步到Redis，所有的操作都基于Redis的原子操作

#### Q9: 这样会不会发生超卖？如何和DB同步？那抢购中商家需要变更商品数量怎么办？如何避免超卖？
A9:
1. 如果抢购之前同步，基于redis的原子操作，不太可能超卖
2. 实时同步不太可能，可以商品被抢购后通过消息来异步同步DB
3. 比如商家将数量从50增加到70，那么此时需要将DB同步至redis,采用incr 20的原子操作，可以避免数据不同步发生超卖

#### Q10: 你们接的支付是什么支付？
A10: 
微信支付

#### Q11: 如果微信回调你失败了，你如何处理？
A11: 像前面说的超时未支付机制会处理，回滚所有占用的资源

#### Q12: 那比如有一件事情，需要一次执行1，2，3步，如何保证1，3发生错误回滚时2不回滚？事务的传播特性了解吗？
A12:
不了解（都没听说过）

#### Q13: 之前你说订单创建完成1小时后，你会检测用户是否付款，没有付款的话，你就去回滚优惠券、库存之类。那么，比如用户在下单后的59分59秒付款了，那这笔订单怎么办？
A13:
如果用户这时候付款，但是在1小时的时候，微信支付的回调可能还没到。这时订单会被认为超时未支付，去回滚所占用的资源。然后回调处理中发现订单已经被取消，就会去走自动退款流程

#### Q14: 这样是不是不合理？微信支付的回调一般多久，如果让你再优化下，你准备怎么做？
A14:
（这个问题确实没考虑到）我看过微信回调的log，基本在1分钟内会有回调。而且我们这边有一个java写的支付系统。那边会通过队列来保证失败重传。
我想可能把这个时间延迟一点，比如说用户1小时后就不能支付了，但真正的超时未支付处理放在5分钟以后，因为微信回调基本都在1分钟内完成

#### Q15: 一般点击下单后，前端会暂时禁止掉下单按钮，防止重复下单，如果前端此时不可控了。你的订单系统如何处理重复下单问题？
A15: 
在下单前，前端需要检测本地有没有一个ticket, 如果没有，请求服务器端，服务器端根据userId生成一个hset, value就是这个ticket。
用户在提交订单的时候，把这个ticket带进来，服务器端通过hdel判断该ticket是否有效，hdel返回成功，则有效，否则无效

#### Q16: 阿里的系统流量巨大，有什么办法处理这种高并发吗？如果对你现有的系统做优化支持高并发，你如何做？
A16: 我觉得可以这样:
1. 前端限流，只放5%-10%的流量进来
2. 将请求hash到多个队列中处理

#### Q17: 如果你们的公司现在订单量巨大，你们是否已经做了分表？
A17:
考虑过，但是按照订单的逻辑，订单code和userId是必须要做为分表属性的，因此可能不可避免的带来数据冗余。由于项目时间过紧，所有没有实施

#### Q18: 那有什么办法可以尽量减少冗余？比如说订单code和userId有一定关联？
A18:
（提示的太明显）可以将userId集成订单code中，这样无论是code和是userId都可以快速的路由到目标表

#### Q19: 负载均衡了解的多吗？如果发现系统中，就某一些用户极其活跃，导致所有的分表中，数据集中在某几个表里，这种情况如何处理？
A19:
(想了一会)确实不了解。据我目前了解的，分表的规则确定了，可能就比较难处理这种问题

#### Q20: 没事，那就再问最后一个业务问题，然后我们再面算法。如果你们的公司运营了几年，DB已经爆满，任何索引都增加不了性能了，如何处理？
A20:
对于这种冷数据，比如今年2017，很少会有用户查询2015年的订单。可以把这些订单按日期导入到其他库中。需要查询的时候，根据订单号去这些库中查询

#### Q21: 订单如何按照日期分？
A21: 我们的订单号里包含了年月日信息

#### Q22: 看你简历你一直写PHP的，了解PHP的内存管理机制吗？
A22:
（这个真不知道）因为PHP的内存回收机制比较完备，所以没有研究过这个方向

#### Q22-PS: 也就是只是用的比较多？你可以研究下，很有意思。

#### Q23: 好，那下面我们进入算法面试。第一题，将一个链表的奇数项和偶数项调换
A23:
(比较常见的算法题)拿笔在纸上写了下。大致如下:
```
struct *linkList trans(linkList *l)
{
    linkList i = l->next;
    linkList j = i->next;
    while (i && j) {
        linkList k = j->next;
        j->next = i;
        i->next = k;
        i = k;
        j = k->next;
    }
    return l;
}
```

#### Q24: 你这种解决方案无论对链表中数量是奇数还是偶数都正常工作吗？
A24:
是的。如果是奇数，那么j就是空，while条件不满足就直接返回了。

#### Q25: 第二题。找一个数组中之和最大的连续子数组
A25: 
(也比较常见了)。是个DP题，但是这种算法丢了很久了，都生疏了，所以第一想法仍然是遍历。思路如下：

1. 记录sum为当前和最大子数组之和
2. 遍历数组，如果sum+当前元素>sum，更新sum
3. 如果sum+当前元素<0,则sum置为0，即表示之前的sum肯定不是最大的（因为空数组也是子数组，空数组和为0）
4. 最后的sum就是最大子数组之和

代码大致如下：

```
int findMaxSubArray(int[] arr)
{
    int sum = 0;
    for ($i = 0; $i < arr.length; $i++) {
        if ($sum + $arr[$i] > $sum) {
            $sum += $arr[$i];
        } else if ($sum + $arr[$i] < 0) {
            $sum = 0;
        }
    }
    return $sum;
}
```

一面结束，整个时间大概在1个小时15分钟左右













