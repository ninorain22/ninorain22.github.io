fmt.Printf format:
+ %d    decimal
+ %x, %o, %b    16进制，8进制，2进制
+ %f, %g, %e    短精度， 长精度，科学计数法
+ %t    boolean
+ %c    rune
+ %s    string
+ %q    quoted string or rune
+ %v    any value in natural format
+ %T    type of any value
+ %%    %

### 第三章 基本数据类型

#### 3.1 Integers
共有4种不同size的带符号整数——8，16，32，64：int8, int16, int32, int64
对应4种无符号整数: uint8, uint16, uint32, uint64

可以用`int`和`uint`来替代具体size的类型，依赖具体的平台

`rune`是`int32`的同义类型，可以互相转换

`byte`是`uint8`的同义类型

`uintptr`用于底层编程，例如Go与C library的调用

介绍两个`fmt`的小技巧：
1. `Printf()`中的`format`出现了多少个%，那么久需要跟上多少个%个参数，可以用%[1]来设置仅使用第一个操作数
```go
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o)  // 438 666 0666
```
2. `rune`一般是用一个单引号的字符，比如'a', 用%c或者%q
```go
ascii := 'a'
unicode := '国'
newline := '\n'
fmt.Printf("%d %[1]c %[1]q\n", ascii)       // 97 a 'a'
fmt.Printf("%d %[1]c %[1]q\n", unicode)     // 22269 国 '国'
fmt.Printf("%d %[1]q\n", newline)           // 10 '\n'
```

#### 3.2 Floating-Point Numbers
2种floating-point类型，`float32`和`float64`

#### 3.3 Complex Numbers
略

#### 3.4 Booleans

#### 3.5 Strings
string是**不可更改**的bytes序列。

`len`函数返回string中`bytes`的数量
```go
s := "hello"
fmt.Println(len(s))
```

`substring`函数`s[i:j]`返回一个新的string，由s[i] ~ s[j-1]

`+=`可以返回一个新的string, 原有的string保持不变，如果后续没有被用，会被GC回收

##### 3.5.1 String Literals
Go的源文件采用UTF-8编码

双引号string literal:
一些常见的转义字符如下:
+ \a:   alert or bell
+ \b:   backspace
+ \f:   form feed
+ \n:   newline
+ \r:   carriage return
+ \t:   tab
+ \v:   vertical tab
+ \':   '
+ \":   "
+ \\:   \

raw string literal:(`...`):
在raw string literal中，任何序列都不会转义。一般用于方便的写正则表达式，HTML模板等


##### 3.5.2 Unicode

##### 3.5.3 UTF-8

##### 3.5.4 Strings and Byte Slices
4个重要的操作string的package: `bytes`, `strings`, `strconv`, `unicode`

虽然包含bytes数组的string一但创建就不可缸盖，但是，byte slice可以任意更改

string和byte[]可以互相转换
```go
s := "abc"
b := []byte(s)
s2 := string(b)
```
但是这种转换都会有额外的内存分配，每次返回的都是一个copy

要尽力避免这样的内存分配，因此`bytes`包和`string`包提供了一些应用函数
+ func Contains(s. substr string) bool
+ func Count(s, seq string) int
+ func Fields(s string) []string
+ func HasPrefix(s, prefix string) bool
+ func Index(s, sep string) int
+ func Join(a []string, sep string) string

+ func Contains(s. subslice []byte) bool
+ func Count(s, seq []byte) int
+ func Fields(s []byte) [][]byte
+ func HasPrefix(s, prefix []byte) bool
+ func Index(s, sep []byte) int
+ func Join(a [][]byte, sep []byte) []byte

`bytes`包提供了一种`Buffer`类型，用于高效的操作`byte slices`
```go
var buf bytes.Buffer
buf.WriteByte('a')      // 用于ASCII编码的字符比如'['或']'
buf.WriteString("bcd")  
buf.WriteRune('a')      // 用于添加UTF-8编码的rune
return buf.String()
```

##### 3.5.5 Convertions between Strings and Numbers
将一个integer转换为一个string, 一个方法是`fmt.Sprintf`，
另外一个就是`strconv.Itoa()`
```go
x := 123
y := fmt.Sprintf("%d", x)
fmt.Println(y, strconv.Itoa(x)) // 123 123
```

可以使用`FormatInt`和`FormatUint`来设置进制
`fmt.Println(strconv.FormatInt(int64(x), 2))`

将一个string转换为integer, 使用`strconv.Atoi()`或者`strconv.ParseInt()`或者`strconv.ParseUint()`
```go
x, err := strconv.Atoi("123")   // x: 123
y, err := strconv.ParseInt("123", 10, 64)   // base 10, 64 bits
```

#### 3.6 Constants
```go
const (
	a = 123
	b = 456
)
```

##### 3.6.1 The Constant Generator iota
类似于`enumeration`
```go
type Weekday int

const (
	Sunday Weekday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
)
```
默认Sunday就是0， Monday是1


##### 3.6.2 Untyped Constants
```go
fmt.Printf("%T\n", 0)           // int
fmt.Printf("%T\n", 0.0)         // float64
fmt.Printf("%T\n", 0i)          // complex128
fmt.Printf("%T\n", '\000')      // int32(rune)
```


### 第四章 Composite Types
`arrays`, `slices`, `maps` and `structs`

`arrays`和`structs`有固定的size， 而`slices`和`maps`是动态的数据结构

#### 4.1 Arrays
固定长度的0个或多个相同类型元素的序列，因为是定长的，所以很少使用。较多使用`slice`
```go
var a [3]int    // 默认都是0
fmt.Println(a[0])
for i, v := range a {
	fmt.Printf("%d %d\n", i, v)
}
```

可以在定义array的时候初始化
```go
var q [3]int = [3]int{1,2,3}
var r [3]int = [3]int{1,2}

// 或者由初始化的个数类决定array的长度
q = [...]int{1,2,3}

// array下表从0开始
r := [...]int{99: -1}   // 初始化为100个元素，第100个为-1，其余都是0
```

在Go中，函数传递参数时，会给每个参数copy一份到函数，在函数体内对参数的改变仅仅对这份copy生效。
Go语言将array和其他类型同样对待，因此，可以通过显示的传一个array的指针来作为参数，以此来改变origin value

#### 4.2 Slices
Slices代表变长的相同类型的元素序列。写作`[]T`

一个slice有3个组成：1个指针，1个长度，1个capacity
+ 指针指向slice在底层数组中第一个元素，不一定是数组第一个元素
+ 长度就是slice元素的个数，`len`
+ capacity就是底层数组中slice的开始到结束所能容纳的元素个数 `cap`

多个slices可以共享一个底层数组

超过`cap(s)`的切片操作会引发`panic`, 超过`len(s)`的切片操作会扩展切片

由于slice包含了一个指向数组的指针，因此，将slice作为函数参数传递可以允许函数修改这个slice
```go
func reverse(s []int) {
	for i,j = 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}
```

和array不同，slice是不可比较的，不能用`==`来判断两个slice是否含有相同元素，
标准库里提供了`bytes.Equal`函数来比较两个bytes slice, 对于其他类型的slice, 就需要自己手动实现

一个slice的0值就是`nil`, 一个nil slice没有底层数组。cap和len都是0。
但是又一些非nil的slice的cap和len也是0，比如`[]int{}`或者`make([]int, 2)[3:]`.
由于任何类型都可以由nil值，因此一个nil的slice可以用以下方式来实现：
```go
var s []int     // len(s) = 0, s = nil
s = nil         // len(s) = 0, s = nil
s = []int(nil)  // len(s) = 0, s = nil
s = []int{}     // len(s) = 0, s != nil
```

因此，当你判断一个slice是否是空的时候，不要用`s == nil`, 而是用`len(s) == 0`

内建的用来创建特定元素类型、长度、和容量的slice方法：
```go
make([]T, len)
make([]T, len, cap)
```
在底层，`make`创建了一个匿名的array变量，然后返回了它的slice


##### 4.2.1 The append Function
内建的`append`函数用于向slice添加元素
```go
var runes []rune
for _, r := range  "hello world" {
	runes = appen(runes, r)
}
```

##### 4.2.2 In-Place Slice Techniques


#### 4.3 Maps
In Go, 一个`map`指向一个hash table, map通常被写作`map[K]V`
```go
ages := make(map[string]int)
```

// 或者用一些初始化数值
ages := map[string]int{
	"alice": 1
	"charlie": 2
}

// 初始化一个空的map的另一种方法
ages := map[string]int{}
```

需要注意的是，map中的元素并不是一个变量，因此没有办法获取其中某个元素的地址
```go
_ = &ages["alice"]      // compile error
```

map的迭代的顺序是不可知的，不同的实现使用了不同的hash函数，因此导致了顺序的不同。
```go
for name, age := range ages {
	fmt.Printf("%s %d\n", name, age)
}
```

map的0值是nil, 也就是没有指向任何hash table
```go
var ages map[string]int
fmt.Println(ages == nil)    // true
fmt.Println(len(ages) == 0) // true

// 未指向hash table的map不能存储数据
ages["carol"] = 22  // panic, assignment to entry in nil map
```
为了判断map中是否存在某个key对应的值：
```go
if age, ok := ages["bob"]; !ok {
	// bob not exist
}
```


#### 4.4 Structs
将0个或多个命名的任意类型的元素组合到一个entity中，struct中每个值称作一个`field`。
```go
type Employee struct {
	ID          int
	Name        string
	Address     string
	DoB         time.Time
	Position    string
	Salary      float64
	ManagerID   int
}
var delibert Employee
```
struct中field的顺序和初始化时的顺序保持一致

没有任何field的struct称作`empty struct`，在Go中通常用于一组map的`bool`,但是一般避免使用
```go
seen := make(map[string]struct{})
// ...
if _, ok := seen[s]; ok {
	seen[s] = struct{}{}
}
```

##### 4.4.1 Struct Literals
第一种
```go
type Point struct { X, Y int }
p := Point{1, 2}
```

第二种，更为常用：
`anim := gif.GIF{LoopCount: nframes}`


Struct也可以用作函数的参数或者返回值，为了效率，通常较大的struct类型采用指针来传递
```go
func Bonus(e *Employee, percent int) int {
	return e.Salary * percent / 100
}
```

##### 4.4.2 Comparing Structs
如果struct里所有的field都是可比较的，那么这个struct才是可比较的。
作为可比较的struct，也可以用作map的key
```go
type address struct {
	hostname string
	port     int
}
hits := make(map[address]int)
hits[address{"golang.org", 433}]++
```

##### 4.4.3 Struct Embedding and Anonymous Fields
```go
type Point struct {
	X, Y int
}

type Circle struct {
	Point           // anonymous field
	Radius int
}

type Wheel struct {
	Circle          // anonymous field
	Spokes int
}

var w Wheel
w.X = 8
w.Y = 8
w.Radius = 5
w.Spokes = 20
```

但是，在初始化struct的时候，只能显示的定义：
```go
w = Wheel{Circle{Point{8, 8}, 5}, 20}

fmt.Printf("%#v\n", w)
```
注意到Printf中的`#`，这可以在打印语句中包括struct的每个field名称


#### 4.5 JSON
Go提供几个标准库可以处理JSON格式，`encoding/json`, `encoding/xml`, `encoding/asn1`等

JSON object通常用于encode maps, structs等
```go
type Movie struct {
	Title       string
	Year        int     `json:"released"`
	Color       bool    `json:"color,omitempty"`
	Actors      []string
}

var movies = []Movie{
	{Title: "Casa", Year: 1942, Color:false, Actors:[]string{"H.B", "I.B"}}
	{Title: "Cool Hand Luke", Year: 1967, Color:false, Actors:[]string{"P.N"}}
	{Title: "Bullitt", Year: 1968, Color:false, Actors:[]string{"S.Mc", "J.B"}}
}

data, err := json.Marshal(movies)

// 更适合阅读的格式
data, err = json.MarshalIndent(movies, "", "    ")
```

仅仅导出的field才会被`Marshal`, 对于上面的`field tag`: `json:"released"`,
在`field tag`中：
+ json: 用于控制marshal和unmarshal中field的替代json字段名称
+ omitempty: 如果该field是0值，那么就不输出在JSON中
```go
var titles []struct{ Title string }
if err := json.Unmarshal(data, &titles); err != nil {
	log.Fatalf("JSON unmarshaling failed: %s", err)
}
fmt.Println(titles)
```

除了`json.Unmarshal`, 也`streaming decoder`: `json.Decoder`, 可以将一个输入流转换成JSON entity.
```go
var result IssuesSearchResult
if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
	...
}
```

#### 4.6 Text and HTML Templates
A template是一个包含包含一个或多个以`{{`和`}}`括起来的片段，称作`action`
```go
const templ = `{{.TotalCount}} issues:
{{range .Items}}-------------------------
    Number: {{.Number}}
    User:   {{.User.Login}}
    Title:  {{.Title | printf "%.64s"}}
    Age:    {{.CreatedAt | daysAgo}} days
{{end}}`

func daysAgo(t time.Time) int {
	return int(time.Since(t).Hours() / 24)
}
```
接下来，将输出到template
```go
report, err := template.New("report").
    Funcs(template.FuncMap{"daysAgo": daysAgo}).
	Parse(templ)
if err != nil {
	log.Fatal(err)
}
```
因为templates通常会在编译的时候固化，失败的parse会导致fatal bug。
可以使用`template.Must`来更方便的处理错误：接收一个template和一个error, 判断这个error是否是nil, 然后返回这个template


### 第五章 函数

#### 5.1 Function Declarations
```go
func name(param-list) (result-list) {
	body
}
```
在Go中，参数都是通过`by value`传递的，因此，函数接收到的参数都是一份copy， 对copy的修改不会影响到调用者。
然而，如果参数包含了某种引用，比如一个指针，slice, map, function或者是channel, 那么调用者会受到函数中对参数修改的影响


#### 5.2 Recursion
函数可以是递归的
`golang.org/x/...`是一个Go team开发和维护的包含大量操作 networking, internationalized text processing, mobile platform,
image manipulation, cryptography等等开发者工具。

`golang.org/x/net/html`包中的函数`html.Parse()`函数支持读取一个bytes序列，解析，然后返回其HTML doc tree, 也就是一个`html.Node`
HTML有很多类型的nodes—— Text, Comments等等

很多语言的函数采用了固定大小的调用栈，典型的是64K到2MB，然而固定大小的调用栈限制了递归的的深度。
Go语言不同，采用了可变代销的调用栈，从一个很小的大小开始，甚至跟着需求会增长到最大1GB，因此Go中的递归是比较安全的


#### 5.3 Multiple Return Values
返回参数可以命名，也可以不命名

命名的多个返回参数，可以不需要return每个参数，或者可以仅仅用`return`即可；
不命名的需要return对应个数的返回值


#### 5.4 Errors
对于一个可能返回失败的函数而言，增加一个额外返回结果，通常放在最后一个，一般叫做`ok`，比如
```go
value, ok := cache.Lookup(key)
if !ok {
	// ...
}
```
更频繁的，特别是IO操作，可能会有非常多的原因导致失败。这时候，额外返回结果就可以是一个`error`类型

内建的`error`是一个接口类型，nil表示成功，non-nil表示失败，失败时error有一个error message来用于描述，可以通过
`fmt.Println(err)`打印出来。

通常当一个函数返回non-nil error时，其他的返回值应该被忽略，但是有一些情况，函数会在错误的是返回部分结果，
比如读取文件时发生了错误，仍然返回可以正常读取了的内容和一个error。

在Go语言中，虽然有异常机制，但是仅仅用来报告一些无法预测的错误，并不是一个健壮的程序应该的可预期的运行时错误


##### 5.4.1 Error-Handling Strategies
当一个函数返回错误，通常由调用者来负责检查并采取对应措施。基于场景，有很多种处理方式。我们先看其中的5种：
1. 最常见的，传播这个错误，在子程序中的错误将会变成调用程序的错误
```go
resp, err := http.Get(url)
if err != nil {
	return nil, err
}
```
另外， 当`html.Parse`发生错误时，函数并不直接返回这个错误，因为它缺少了一些用于定位错误的信息，比如`url`,等
```go
doc, err := html.Parse(resp.Body)
resp.Body.Close()
if err != nil {
	return nil, fmt.Errorf("passing %s as HTML: %v", url, err)
}
```
2. 当遇到了暂时性或不可预测性的问题，通常可以尝试`retry`操作
3. 当程序无法运行，调用者打印错误并且优雅的结束程序。这种方式仅仅推荐在main package中使用，库函数更应该将错误传播给调用者
```go
// In function main
if err := WaitForServer(url); err != nil {
	fmt.Fprintf(os.Stderr, "Site is down: %v\n", err)
	os.Exit(1)
}
// 可以用更简单的方式来达到同样的效果，就是`log.Fatalf`
if err := WaitForServer(url); err != nil {
	log.Fatalf("Site is down: %v\n", err)
}
```
4. 有些情况，仅仅记录下error然后继续运行也可以接受
```go
if err := Ping(); err != nil {
	log.Printf("ping failed: %v; networking disabled", err)
}
```
5. 很少时候，可以安全的忽视掉错误
```go
dir, err := ioutil.TempDir("". "scratch")
if err != nil {
	return fmt.Errorf("failed to create temp dir: %v", err)
}

// use temp dir
os.RemoveAll(dir)   // 忽略错误，因为就算操作失败，OS也会定期的清理临时文件
```

##### 5.4.2 End of File(EOF)
```go
in := bufio.NewReader(os.Stdin)
for {
	r, _, err := in.ReadRune()
	if err == io.EOF {
		break
	}
	if err != nil {
		return fmt.Errorf("read failed: %v", err)
	}
	// ...
}
```

#### 5.5 Function Values
函数变量有类型，可以被赋值给其他变量或者从函数传递/返回

函数变量的0值是nil, 调用nil函数会触发panic
```go
var f func(int) int
f(3)    // panic
```


#### 5.6 Anonymous Functions
命名函数仅可以在package level几倍定义，但是可以在任何地方定义匿名函数
```go
strings.Map(func(r rune) rune { return r + 1}, :"HAL-9000")
```
更重要的是，定义的匿名函数享有当前词汇环境的访问权，因此函数内部可以引用到函数内的变量
```go
func squares() func() int {
	var x int
	return func() int {
		x ++
		return x*x
	}
}

func main() {
	f := squares()
	fmt.Println(f())    // 1
	fmt.Println(f())    // 4
	fmt.Println(f())    // 9
	fmt.Println(f())    // 16
}
```
对`suqares()`函数的调用，创建了一个local变量x，以及返回一个匿名函数，
每当这个函数被调用时，就会增加x，然后返回x的平方

这也说明了函数值在Go中是以引用类型来传递，并且不可比较。
函数值使用了闭包技术。


##### 5.6.1 Caveat: Capturing Iteration Variables
```go
var rmdirs []func()
for _, d := range tempDirs() {
	dir := d
	os.MkdirAll(dir, 0755)
	rmdirs = append(rmdirs, func() {
		os.RemoveAll(dir)
	})
}
// .. some work
for _, rmdir := range rmdirs {
	rmdir()
}
```
上面的代码中，**`dir := d`这行必不可少**。
原因是loop变量的一系列作用域问题导致的。
如果直接将dir做为循环变量，对于第一个for语句，引入了一个新的语义块，其中定义了变量dir，
那么这个循环中创建的所有函数变量都可以共享相同的变量。
这个dir变量随着循环不断更改，等到第二个循环执行清除操作时，这个dir已经被更新多次，已经是循环的最后一个值了，
因此第二个循环始终值清除最后一个目录

迭代变量的捕获问题域经常发生使用`go`语句或者使用`defer`语句的时候


#### 5.7 Variadic Functions
最常见的可变函数就是`fmt.Printf`， 可以接受1个或多个参数
通过将最后一个参数的类型前添加`...`，可以将一个函数变为可变函数
```go
func sum(vals ...int) int {
	total := 0
	for _, val := range vals {
		total += val
	}
	return total
}
```
可以如下调用
```go
sum(1,2,3,4)
values := []int{1,2,3,4}
sum(values...)
```


#### 5.8 Deferred Function Calls
一个`defer`语句一般是一个普通的函数或者在方法前面添加`defer`关键词，
函数和参数表达式会在申明的时候立即求值，但是真正的函数调用会推迟到函数结束，无论是不是正常结束，
可以是一个return返回，或者直接运行到结尾，也可以是一个panic导致的结束

可以定义任意多数量的defer，但是它们执行的顺序与定义的顺序相反，类似栈

`defer`语句通常用来成对的操作，比如`open`和`close`, `connect`和`disconnect`， `lock`和`unlock`等。
正确的使用defer释放一个资源的地方就是在成功获取资源的下面一句使用

`defer`的函数会在return语句之后执行。由于匿名函数可以访问其闭包内的函数变量，以及命名的返回值，一个defer的匿名函数可以观察函数的返回结果
```go
func double(x int) int {
	return x + x
}
// =>
func doube2(x int) (result int) {
	defer func() { fmt.Printf("double(%d) = %d\n", x, result)}()
	return x + x
}
double2(4)  // "double(4) = 8
```
一个defer的匿名函数甚至可以修改其封闭函数返回给调用者的值
```go
func triple(x int) (result int) {
	defer func() { result += x }()
	result = double(x)
}
```

由于defer的函数是在函数的最后执行，因此在一个在循环里的defer语句就需要仔细考量，
比如下面的例子中，文件描述符很可能被用完
```go
for _, filename := range filenames {
	f, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer f.Close()     // !!! 可能导致文件描述符耗尽
	// process f
}
```
一个解决方法就是讲循环体移出来单独作为一个函数，函数里使用defer
```go
for _, filename := range filenames {
	if err := doFile(filename); err != nil {
		return err
	}
}

func doFile(filename string) error {
	f, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer f.Close()
	// process f
}
```


#### 5.9 Panic
Go的类型系统可以捕获很多编译错误，但是，类似于一些超出数组边界，或者空指针引用，只能在运行时检查，
当Go运行时检测到这些问题，就会触发panic

在一个典型的panic发生时，正常的程序执行被停止，所有当前goroutine中defer的函数将被执行, 程序携带一个log信息并崩溃，
log信息包括了`panic value`, 对每个goroutine而言，就是一个`stack trace`信息，显示了当panic发生时，函数调用栈里的信息。

log信息里还包括了足够用来诊断问题发生的原因的信息，因此，最好在可能发生panic的程序中包含一个bug报告

不是所有的panic都只能从运行时发生，内建的`panic`函数可以直接被调用，接收任意的值作为参数

在Go中，panic通常仅用来处理重大的错误，比如程序的逻辑不一致。而一些错误的输入、错误配置、失败的I/O等，最好用error来处理


#### 5.10 Recover
如果在一个defer的函数中调用内建的`recover`函数，`recover`会终结当前的panic状态并且返回`panic value`
```go
func Parse(input string) (s *Syntax, err error) {
	def func() {
		if p := recover(); p != nil {
			err = fmt.Errorf("internal error: %v", p)
		}
	}()
	//...
}
```

无差别的从任何panic中恢复显然是不可取的操作，一般而言，不要尝试去从其他package的panic中恢复。公开的API会通过`errors`来报告错误。
也就是说，不要从不是你维护的代码的panic中尝试恢复。

总的来说，需要从panic中恢复的情况是极其少见的。



### 第6章 方法

#### 6.1 Method Declarations
```go
package geometry

import "math"

type Point struct { X, Y float64 }

func Distance(p, q Point) float64 {
	return math.Hypot(q.X - p.X, q.Y - p.Y)
}

func (p Point) Distance(q Point) float64 {
	return math.Hypot(q.X - p.X, q.Y - p.Y)
}
```
这里的`p`被称为方法的接收者，在Go语言中，不使用this或者self，而使用接收者参数的名称。
由于方法和字段共享同一个命名空间，因此，类型的方法名称不能与类型里字段的名称冲突

由于每个类型都有自己的命名空间，因此，同一个方法名可以用于不同的类型。


#### 6.2 Methods with a Pointer Receiver
因为函数调用时会copy每个参数的值，因此，如果一个函数需要修改变量，或者参数太大，那么就要避免copy，因此可以通过传递指针的方式将地址传入函数。
这对方法来说同样如此
```go
func (p *Point) ScaleBy(factor float64) {
	p.X *= factor
	p.Y *= factor
}
```
在编程中，对于某一个type，如果某些方法提供了指针接收者，那么最好给这个type所有的方法提供一个指针接收者

为了避免混淆，Go中不允许一个本来就是指针的type作为方法的接收者，如下
```go
type P *int
func (P) f() { /* ... */ }  // compile error
```

如果接收者是一个type变量，但是方法需要一个type的指针，我们依然可以直接使用`p.ScaleBy(2)`，因为指针的转换会自动帮你完成

但是这仅仅针对变量，包括struct中的字段，或者slice/array中的元素，无法在一个*Point的方法中使用一个non-addressable的Point作为接收者
```go
Point{1, 2}.ScaleBy(2)      // compile error
```

同样的，我们可以使用一个*Point作为Point.Distance的接收者，编译器会自动将其取值，下面的两个方法是相同的：
```go
pptr.Distance(q)
(*pptr).Distance(q)
```

如果一个类型T的所有方法都有一个T的接收者，那么这个实例的拷贝是安全的，因为任何方法都会做一份copy。
如果一个方法有指针作为接收者，那么就要避免拷贝这个实例，因为可能会修改内部的变量，比如`bytes.Buffer`,
`bytes.Buffer`实例的拷贝会将原始拷贝一份副本，但是底层的字节数组仍然是相同的


##### 6.2.1 Nil Is a Valid Receiver Value
有些函数允许nil指针作为参数，同样的，有些方法也可以用nil来作为接收者，特别是nil是一个有意义的0值，比如对于maps或者slices而言
```go
type IntList struct {
	Value   int
	Tail    *IntList
}

func (list *IntList) Sum() int {
	if list == nil {
		return 0
	}
	return list.Value + list.Tail.Sum()
}
```


#### 6.3 Composing Types by Struct Embedding
```go
import "image\color"

type Point struct { X, Y float64 }

type ColoredPoint struct {
	Point
	Color color.RGBA
}
```
这样，`Point`的方法都会被提升到`ColoredPoint`中，通过这种方法，类型嵌套就允许了构建复杂类型，每个field都可以由一些方法。
这与OO中的子类和父类的方法不同。这是一种组合。

匿名的field也可以是一个type的指针
```go
type ColoredPoint struct {
	*Point
	Color color.RGBA
}
p := ColoredPoint{&Point{1, 2}, red}
q := ColoredPoint{&Point{3, 4}, blue}
```

一个struct类型可以由多个匿名field，如下：
```go
type ColoredPoint struct {
	Point
	color.RGBA
}
```
这与一来，ColoredPoint类型的一个值就拥有所有Point的方法，所有RGBA的方法，以及所有直接声明在ColoredPoint上的方法。

当编译器尝试解析一个类似于`p.ScaleBy`的方法时：
1. 首先在ColoredPoint上查找有没有直接定义的方法
2. 如果1没找到，就从ColoredPoint内嵌的fields中查找有没有被提升的叫做ScaleBy的方法
3. 如果2没找到，继续从Point和RGBA中查找有没有被提升的叫做ScaleBy的方法
4. 以此类推，直到没有嵌套或者找到为止

当同一优先级中找到多个方法满足，那么编译器会报错，比如Point和RGBA都有一个`ScaleBy`方法



#### 6.4 Method Values and Expressions
通常，我们直接调用一个函数，比如`p.Distance()`，实际上，可以将其拆分为2步。
选择器`p.Distance`生成一个`method value`, 一个绑定Point.Distance方法的函数，这个函数可以被再次调用，而不需要再提供receiver
```go
p := Point{1, 2}
q := Point{3, 4}

distanceFromP := p.Distance
fmt.Println(distanceFromP(q))

var origin Point
fmt.Println(distanceFromP(origin))
```

当一个包的API调用一个`function value`时，同时客户端希望这个函数可以调用一个特定接收者的方法，这时`Method values`是非常有用的
```go
type Rocket struct { ... }
func (r *Rocket) Launch() { ... }
r := new(Rocket)
time.AfterFunc(10 * time.Second, func() { r.Launch() })
// 也可以写作
time.AfterFunc(10 * time.Second, r.Launch)
```

和`method value`相关的就是`method expression`, 当调用一个方法，不同于普通函数，我们必须按特殊的格式提供接收者，

`method expression`, 写作`T.f`或者`(*T).f`, 生成一个`function value`,第一个参数就是接收者
```go
p := Point{1, 2}
q := Point{3, 4}

distance := Point.Distance
fmt.Println(distance(p, q))

scale := (*Point).ScaleBy
scale(&p, 2)
```


#### 6.5 Example: Bit Vector Type
在Go中，Set通常通过`map[T]bool`来实现

例如，在数据流分析领域，set的元素通常都是非负整数，set的操作比如`union`和`intersection`比较常见，因此`bit vector`是一个更好的选择
```go
type IntSet struct {
	words []uint64
}

func (s * IntSet) Has(x int) bool {
	word, bit := x/64, uint(x%64)
	return word < len(s.words) && s.words[word]&(1<<bit) != 0
}

func (s *IntSet) Add(x int) {
	word, bit := x/64, uint(x%64)
	for word >= len(s.words) {
		s.words = append(s.words, 0)
	}
	s.words[word] |= 1 << bit
}

func (s *IntSet) UnionWith(t * IntSet)  {
    for i, tword := range t.words {
    	if i < len(s.words) {
    		s.words[i] |= tword
    	} else {
    		s.words = append(s.words, tword)
    	}
    }
}
```


#### 6.6 Encapsulation 封装
在Go中，为了封装一个Object, 我们需要将其struct化，这就是上面的IntSet申明为一个struct类型，即使只有1个字段

我们可以这样重新定义IntSet: `type IntSet []uint64`,
尽管这样和上面struct方式定义没有区别，但是这样允许任何package外的调用者直接访问这个slice，换句话说，*s可以在任何package中使用，
而s.words仅仅在IntSet所定义的package中可见

举个例子来说，`bytes.Buffer`类型，通常用于积累小的字符串，有助于优化内存分配，`Buffer`是一个struct, 内部封装了一个64字节大小的起始slice.
对于调用者而言，完全可以不关心内部是如何优化内存分配的。

同样，封装也有利于防止调用者随意的更改对象的属性



### 第7章 Interfaces

#### 7.1 Interfaces as Contracts
Go中还有一种类型称作`interface type`， 一个interface是一个抽象类型。并不向外暴露自己的内部结构或者支持的基本操作。
仅仅是暴露其可以支持的方法。所以当你有一个interface类型的值，你不会知道它真正是什么，你所唯一可以知道的吗，就是它可以提供的方法

```go
package fmt

func Fprintf(w io.Writer, format string, args ...interface{}) (int, error)

func Printf(format string, args ...interface{}) (int, error) {
	return Fprintf(os.Stdout, format, args...)
}

func Sprintf(format string, args ...interface{}) string {
	var buf bytes.Buffer
	Fprintf(&buf, format, args)
	return buf.String()
}
```
Fprintf的第一个参数也不是一个文件，是一个`io.Writer`，是一个接口类型
```go
package io

type Writer interface{
	Write(p []byte) (n int, err error)
}
```

#### 7.2 Interface Types
`io.Writer`是Go中最为广泛应用的一个interface type, 定义了一个一个所有类型的抽象来表明哪些byte可以被用来写操作，包括文件、内存buffers、
网络连接、HTTP客户端、hasher等等。

除此之外，`io`包中定义了很多有用的接口，包括`Reader`, `Closer`等等


#### 7.3 Interface Satisfaction
一个类型满足一个接口，必须要实现这个接口所定义的所有方法。比如，`os.File`就满足了`io.Reader`, `io.Writer`, `io.Closer`和`io.ReadWriter`，
`*bytes.Buffer`满足了`Reader`, `Writer`, `ReadWriter`接口，但并不满足`Closer`接口。

接口可转让性规则：只要一个表达式的类型符合这个接口，那么这个表达式就可以被赋值给这个接口
```go
var w io.Writer
w = os.Stdout
w = new(bytes.Buffer)
w = time.Second // compile error

var rwc io.ReadWriteCloser
rwc = os.Stdout
rwc = new(bytes.Buffer) // compile error
```

看下面这个例子，`IntSet`的`String`方法需要一个指针作为receiver, 因此我们不能在一个无地址的IntSet值上调用这个方法
```go
type IntSet struct {...}
func (*IntSet) String() string

var _ = IntSet{}.String()   // compile error
// 但是可以在一个`IntSet`变量上调用
var s IntSet
var _ = s.String()
```
然而，*IntSet只要一个String方法，因此`*IntSet`满足`fmt.Stringer`接口
```go
var _ fmt.Stringer = &s // ok
var _ fmt.Stringer = s  // compile error
```

对于一个不包含任何方法的接口：`interface{}`, 就是一个空接口类型，因为空接口类型不限制满足它的类型，因此可以将任何值赋值给这个空接口
```go
var any interface{}
any = true
any = 12.34
any = "hello"
any = map[string]inyt{"one":1}
any = new(bytes.Buffer)
```

在将任意类型的值赋值给一个空接口之后，我们不能直接取得这个空接口里的值，我们需要使用`type assertion`来获取


#### Parsing Flags with flag.Value
```go
var period = flag.Duration("period", 1*time.Second, "sleep period")

func main() {
	flag.Parse()
	fmt.Printf("sleep for %v", *period)
	time.Sleep(*period)
	fmt.Println()
}
```
默认是1s，可以通过`-period`flag来更改，`flag.Duration`创建一个`time.Duration`类型的flag变量和，并且允许用户可以用友好的格式
来指定这个duration。
```go
go run sleep -perioo 50ms
go run sleep -perioo 2m50s
go run sleep -perioo 1.5h
go run sleep -perioo 1h30m0d
go run sleep -perioo "1 day"    // invalid
```

#### 7.5 Interface Values
从概念上来说，一个接口类型的值，或者一个`interface value`,有两部分组成，一个具体的类型和这个类型的值，也称作接口的
`dynamic type`和`dynamic value`

在Go语言中，每个变量都会有一个默认初始化值，接口也不例外。一个接口的0值就是它的type和value都是nil.

interface value是可以比较的，只有在它们都是nil. 或者dynamic types相同并且dynamic values也相同时，两个interface value才是相同的。
因此interface values可以用作map的key或者一个switch语句

然而，如果两个interface value有相同的dynamic type,但是 这个type却是不可比较的，那么interface value的比较就会触发panic
```go
var x interface{} = []int{1,2,3}
x == x // panic
```

##### 7.5.1 Caveat: An Interface Containing a Nil Pointer Is Non-Nil
一个nil的接口值，不包含任何值，和一个包含Nil指针的接口值并不一样
```go
const debug = true
func main() {
	var buf *bytes.Buffer
	if debug {
		buf = new(bytes.Buffer)
	}
	f(buf)
	if debug {
		//... use buf ...
	}
}

func f(out io.Writer) {
	if out != nil {
		out.Write([]byte("done\n"))
	}
}
```
这里，当将debug改为false，目的是禁止掉输出，但是代码在这里会触发panic
```go
if out != nil {
	out.Write([]byte("done\n"))
}
```
这时，一个nil的指针类型*bytes.Buffer被赋值给了out, 所以out的dynamic value是nil, 但是dynamic type是*bytes.Buffer, 也就是说，
out并不是一个nil的接口值，因此, `out != nil`是成立的

解决方法就是，在定义buf的时候，定义成`io.Writer`
```go
var buf io.Writer
if debug {
	buf = new(bytes.Buffer)
}
f(buf)  // ok
```


#### 7.6 Sorting with sort.Interface
`sort`包提供了任意序列基于任意排序机制的原地排序函数。
Go语言对序列或者元素的类型不做任何要求，仅仅使用一个`sort.Interface`的接口，这个接口制定了排序算法的合约
```go
package sort

type Interface interface {
	Len() int
	Less(i, j int) bool
	Swap(i, j int)
}
```
为了给任何类型的序列排序，我们需要定义一个实现这3个方法的类型，然后使用`sort.Sort`方法即可。举个例子，string slice的排序：
```go
type StringSlice []string

func (p StringSlice) Len() int { return len(p) }
func (p StringSlice) Less(i, j int) bool { return p[i] < p[j] }
func (p StringSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] }
```
这样，就可以给一个string slice排序了：
```go
sort.Sort(StringSlice(names))
```

对于一些常见类型的排序，sort包已经提供了`StringSlice`类型，仅仅需要`sort.String(names)`即可

Go还提供了`IsSorted`方法来判断一个序列是否已经是有序的。和`sort.Sort`一样，将序列和排序函数用`sort.Interface`抽象出来，，只是不调用`Swap`方法

为了方便，`sort`包为`[]int`, `[]string`, `[]float64`类型和函数都提供了相关的方法。


#### 7.7 The http.Handler Interface
`net/http`包提供了一个`ServeMux`, 一个`request multiplexer`, 简单的将URLs和handler关联起来
```go
type databse map[string]float64

func main() {
	db := database{"shoe": 50, "socks": 5}
	mux := http.NewServeMux()
	mux.Handle("/list", http.HandlerFunc(db.list))
	mux.Handle("/price", http.HandlerFunc(db.price))
	log.Fatal(http.ListenAndServe("localhost:8080", mux))
}
```

为了方便，`net/http`提供了一个全局的`ServeMux`实例，称作`DefaultServeMux`, 
以及两个包级别的函数，`http.Handle`以及`http.HandleFunc`, 为了使用`DefaultServeMux`, 我们将
`ListenAndServe`的第二个参数设置为`nil`即可
```go
func main()
{
	db := database{"shoe": 50, "socks": 5}
	http.HandleFunc("/list", db.list)
	http.HandleFunc("/price", db.price)
	log.Fatal(http.ListenAndServe("localhost:8080", nil))
}
```

这里还有一个重要的提示：web server会在一个新的goroutine中执行handler, 因此，handlers在使用类似于对变量`locking`之类的操作时，必须多加小心。
因为，相同的handler的不用请求，也可能要访问这个变量


#### 7.8 The error Interface
error也是一个接口类型，定义如下
```go
type error interface {
	Error() string
}
```
最简单的创建一个error的方法就是调用`errors.New`, 将会返回一个带有特定message的error

但是很少直接这么用，因为有很多方便的封装的方法，比如`fmt.Errorf`
```go
package fmt

import "errors"

func Errorf(format string, args ...interface{}) error {
	return errors.New(Sprintf(format, args...))
}
```


#### 7.9 Example: Expression Evaluator
略

#### 7.10 Type Assertion
`type assertion`是一个应用在`interface value`上的操作，形式如`x.(T)`, 其中x是interface type的表达式，T是一个类型，称作断言类型。

一个`type assertion`检查interface value的`dynamic type`, 有两种可能：
1. 如果断言类型T是一个具体类型，那么这个`type assertion`就会检查x的dynamic type是否是T，如果检查成功，会返回x的`dynamic value`, 如果检查失败，
会触发panic
```go
var w io.Writer
w = os.Stdout
f := w.(*os.File)   // success
c := w.(*bytes.Buffer)  // panic
```
2. 如果断言类型T也是一个`interface`类型，那么`type assertion`就会检查x的`dynamic type`是否满足T，如果检查成功，不会抽取出dynamic value，
返回结果仍然是一个interface类型，type和value都保持不变，但是含有一个interface type: T.
也就是说，一个接口类型的`type assertion`改变了x的type, 一般是获得了更多方法的权限，但是依然保持不变的`dynamic type`和`dynamic value`
```go
var w io.Writer
w = os.Stdout
rw := w.(io.ReadWriter) // success, *os.File同时有Read和Write
```

无论哪种类型被断言，如果操作数是一个nil的`interface value`, 结果都会失败

为了避免操作触发panic, 可以提供第二个接收参数返回断言结果
```go
var w io.Writer = os.Stdout
f, ok := w.(*os.File)   // ok f == os.Stdout
b, ok := w.(*bytes.Buffer)  // !ok b == nil
```
一般为了方便继续使用，会将断言后的结果赋值回给自身
```go
if w, ok := w.(*os.File); ok {
	// 继续使用w
}
```


#### 7.11 Discriminating Errors with Type Assertions
略

#### 7.12 Querying Behaviors with Interface Type Assertions
略

#### 7.13 Type Switches
Interface通常用于两种不同的类型，第一种，典型的就是`io.Reader`, `io.Writer`, `fmt.Stringer`,
`sort.Interface`, `http.Handler`以及`error`， 一个接口方法表达了这些具体满足了接口的具体接口类型的相似性，
但是隐藏了代表性的细节和一些内在的操作，主要在于方法，而不是具体的类型。

第二种，应用了接口值的能力来保存一个可变类型的值，也就是接口可以认为是这些类型的union。
Type Assertion用来动态的区别这些类型，这里主要在于具体的类型，而不是接口的方法。
```go
switch x.(type) {
    case nil: //
    case int, uint: //
    case bool:  //
    case string: //
    default: //
}
```

#### 7.15 A Few Words of Advice
当设计一个新的package时，仅当面对两个或多个具体类型需要按照统一的操作方式处理时，才考虑使用interface, 否则，interface就是不必要的抽象，它们会有运行损耗。

interface的设计尽量最小化，包含少量的方法，甚至仅仅一个方法。


### 第8章 Goroutines and Channels
Go支持两种形式的并行，第一种是goroutines和channels, 另一种就是共享内存的多线程模式，和其他支持多线程的编程语言类似

#### 8.1 Goroutines
goroutine和线程类似。
```go
f() // 直接调用f(), 等待返回
go f()  // 创建一个新的goroutine来调用f(), 不等待返回
```

**当main函数返回时，所有的goroutine都会被突然中止并且退出程序**。除了从main函数中返回或者退出程序，没有一种可编程的方法可用让一个goroutine来中止另一个goroutine, 但是
有很多可用和goroutine通信的方式来中止

#### 8.2 Examples: Concurrent Clock Server
```go
package main

import (
	"io"
	"log"
	"net"
	"time"
)

func handleConn(c net.Conn)  {
	defer c.Close()
	for {
		_, err := io.WriteString(c, time.Now().Format("15:04:05\n"))
		if err != nil {
            return			
		}
		time.Sleep(1 * time.Second)
	}
}

func main()  {
	listener, err := net.Listen("tcp", "localhost:8080")
	if err != nil {
		log.Fatal(err)
	}
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Print(err)
			continue
		}
		handleConn(conn)
	}
}
```
在上面的例子中，一个client必须要等到上一个client结束才会得到响应，因为server是顺序的，一次只能处理一个client. 仅仅将handleConn使用go就可以处理多个client
```go
for {
	conn, err := listener.Accept()
	if err != nil {
		log.Print(err)
		continue
	}
	go handleConn()
}
```

#### 8.3 Example: Concurrent Echo Server
8.2中的例子为每个connection使用了一个goroutine, 在下面的例子中，我们将为每个connection使用多个goroutines.
```go
func echo(c net.Conn, shout string, delay time.Duration) {
	fmt.Fprintln(c, "\t", strings.ToUpper(shout))
	time.Sleep(delay)
	fmt.Fprintln(c, "\t", shout)
	time.Sleep(delay)
	fmt.Fprintln(c, "\t", strings.ToLower(shout))
}

func handleConn(c net.Conn) {
	input := bufio.NewScanner(c)
	for input.Scan() {
		echo(c, input.Text(), 1 * time.Second)
	}
	c.Close()
}
```
但是，在一个client中，第二行输入必须要等到第一行输入结果全部返回才会开始返回，这不符合实际，因此，我们这里需要多个goroutine
```go
func handleConn(c net.Conn) {
	input := bufio.NewScanner(c)
	for input.Scan() {
		go echo(c, input.Text(), 1 * time.Second)
	}
	c.Close()
}
```

#### 8.4 Channels
channel是一种可以让一个goroutine和另一个goroutine相互通信的机制。每一个channel都是一种特定类型的数值管道。
```go
ch := make(chan int)
```
channel是引用的，因此，当将channel作为函数参数调用时，函数体内对channel的操作将会影响到channel本身。

channel有2个最基本的操作，`send`和`receive`
```go
ch <- x // send x to ch
x = <-ch    // use x to receive from ch
<-ch    // receive from ch and just discard it
```
channel还有一个操作`close`，如果一个channel被close, 那么就不允许任何的`send`操作，否则都会触发panic. `recever`一个close的channel将会一直接受到channel没有任何值可以发送为止

简单的使用make创建一个channel称为unbuffered channel, 可以通过第二个参数来让这个channel可以容纳一些数据，也就是buffered channel
```go
ch = make(chan int)     // unbuffered
ch = make(chan int, 3)  // buffered with capacity 3
```

##### 8.4.1 Unbuffered Channels
给一个unbuffered channel发送数据将会导致block, 直到另外一个goroutine从这个channel中取出了这个值。
相似的，在一个unbuffered channel上接收数据将会一直block到另一个goroutine向这个channel发送了值为止

unbuffered channel上的通信可以让sending goroutine和receiving goroutine同步，因此，unbuffered channel也叫做同步channel

在一些并发访问变量的程序中，顺序非常重要。
在8.3节中的client程序中，在main goroutine中将输入拷贝至server，所以如果input stream结束，client程序会立即终止，为了让程序可以等到后台goroutine完成以后再退出，
可以使用channel来同步这两个goroutine
```go
func main() {
	conn, err := net.Dial("tcp", "localhost:8080")
	if err != nil {
		log.Fatal(err)
	}
	done := make(chan struct{})
	go func() {
		io.Copy(os.Stdout, conn)
		log.Println("done")
		done <- stuct{}{}   // signal the main goroutine
	}()
	mustCopy(conn, os.Stdin)
	conn.Close()
	<-done  // wait for background goroutine to finish
}
```
当用户退出标准输入，`mustCopy`返回，main goroutine调用`conn.Close()`，在后台goroutine返回之前，后台goroutine会记录一条信息，然后发送done给channel，
main goroutine会一直等到接收到这个值才会返回，结果就是程序在退出前会log下"done".

如果channel仅仅是用来同步，可以使用`struct{}`类型的channel

##### 8.4.2 Pipelines
channel可以用来将goroutine串联起来，一个的输出时另一个的输入，称作管道
```go
func main() {
	naturals := make(chan int)
	squares := make(chan int)
	
	go func() {
		for x := 0; ; x++ {
			naturals <- x
		}
	}()
	
	go func() {
		for {
			x := <-naturals
			squares <- x * x
		}
	}()
	
	for {
		fmt.Println(<-squares)
	}
}
```
当一个channel被close之后，所有的send操作都会触发panic, 当channel中所有的元素都被接收完成后，所有的后续接收操作不会block而是直接返回一个
0值。因此，在上面的程序中，如果naturals被close之后，square的for循环中，x会收到一个持续不断的0值，for循环也无法退出。

没有直接的方法来判断一个channel是否被closed，但是一个receive操作可以产生两个结果：`received channel element`和`bool value`.
因此，可以通过如下的方法来判断一个channel是否被close
```go
go func() {
	for {
		x, ok := <-naturals
		if !ok {
			break
		}
		squares <- x * x
	}
	close(squares)
}()
```
但是这种写法过于繁琐，因此可以用`range`循环来替代
```go
func main() {
	naturals := make(chan int)
	squares := make(chan int)
	
	go func() {
		for x:=0; x<10; x++ {
			naturals <- x
		}
		close(naturals)
	}()
	
	go func() {
		for x := range naturals {
			squares <- x * x
		}
		close(squares)
	}()
	
	for x := range squares {
		fmt.Prinln(x)
	}
}
```
并不需要手动的关闭channel, 仅仅在需要告知接收goroutine所有数据都被发送完成时，才有必要close一个channel。
close一个已经closed的channel或者一个nil channel，都会触发panic

##### 8.4.3 Unidirectional Channel Types
`chan<- int`表明这是一个仅仅可以发送的channel
`<-chan int`表明这是一个仅仅可以接收的channel


##### 8.4.4 Buffered Channels
```go
ch := make(chan string, 3)
ch <- "A"
ch <- "B"
ch <- "C"
```
当channel没有超过capacity时，向其的发送操作不会block，如果channel满了。发送操作会block到另一个goroutine接收掉一个值

不要将buffered channel作为一个单goroutine中的一个队列来使用，因为如果没有另一个goroutine来接收，程序就可能在向channel发送数据时block.

在unbuffered和buffered channel之间的选择，以及buffered channel的capacity的选择，都会影响到程序的正确性。
+ unbuffered channel提供了强大的同步性来保证每个send操作对应其receive操作
+ buffered channel中，send和receive是解耦的

另外，当我们知道一组需要发送到channel的数据量的上限时，一般会想到创建一个足够大小的bufferd channel，
因为没有分配足够的buffer空间往往会导致程序死锁。

#### 8.5 Looping in Parallel
没有一个直接的方法来等待一个goroutine结束，但是我们可以改变inner goroutine，当其结束时，发送一个事件给一个公共的channel来告知outer goroutine.
```go
func makeThumbnails3(filenames []string) {
	ch := make(chan struct{})
	for _, f := range filenames {
		go func(f string) {
			thumbnail.ImageFile(f) // NOTE: ignoring errors
			ch <- struct{}{}
		}(f)
	}

	// Wait for goroutines to complete.
	for range filenames {
		<-ch
	}
}
```
注意到我们将f作为参数传递给了并行的goroutine中，这是因为上面的变量f, 是被所有这些匿名函数共享的，并且随着循环迭代被更新，
等到新的goroutine来执行这个函数时，f已经被for循环更新到另一个迭代的值或者是最后一个值，所以等到goroutine读取f的时候，
f是循环的最后一个值。通过将f显式的作为参数传递可以保证f就是go语句执行时的值

如果想要从每个worker goroutine中返回值到main goroutine中，该如何处理？
```go
func makeThumbnails4(filenames []string) error {
	errors := make(chan error)

	for _, f := range filenames {
		go func(f string) {
			_, err := thumbnail.ImageFile(f)
			errors <- err
		}(f)
	}

	for range filenames {
		if err := <-errors; err != nil {
			return err // NOTE: incorrect: goroutine leak!
		}
	}

	return nil
}
```
上面的程序在出现第一个非nil报错之后，后面的goroutine在尝试发送error到channel时就会block，造成OOM错误。
一个简单的解决方案就是用一个足够大小的buffered channel。

但是最终的解决方案如下，返回总的新file所占用的字节数，和之前版本不同，它以string类型的channel来接收文件名参数，因此我们不知道循环的迭代次数

为了知道最后一个goroutine何时结束，我们需要在每个goroutine开始前增加一个计数器，然后在完成的时候减去一个计数器。
一个可以多goroutine并行的计数器类型是`sync.WaitGroup`, 代码如下：
```go
func makeThumbnails6(filenames <-chan string) int64 {
	sizes := make(chan int64)
	var wg sync.WaitGroup // number of working goroutines
	for f := range filenames {
		wg.Add(1)
		// worker
		go func(f string) {
			defer wg.Done()
			thumb, err := thumbnail.ImageFile(f)
			if err != nil {
				log.Println(err)
				return
			}
			info, _ := os.Stat(thumb) // OK to ignore error
			sizes <- info.Size()
		}(f)
	}

	// closer
	go func() {
		wg.Wait()
		close(sizes)
	}()

	var total int64
	for size := range sizes {
		total += size
	}
	return total
}
```
在面对未知迭代次数的循环时，上面的代码是一种常见的处理模式。


#### 8.7 Multiplexing with select
如果需要同时等待多个channel上事件的到来，我们需要一个多路复用器，称作`select`语句
```go
select {
    case <-ch1:
    	//...
    case x := <-ch2: 
    	//...
    case ch3 <- y:
    	//...
    default:
    	//...
}
```
select和switch语句类似，有多个case和一个default

一个select语句会等到某一个case准备好，然后执行对应case下的语句。如果一个select没有任何case，`select{}`,那么会永远等待下去。
如果多个case同时准备好，那么select会随机挑选一个执行。

`time.Tick`方法比较方便，但是仅适合于应用声明周期都存在的情况，否则，使用`NewTicker`
```go
ticker = time.NewTicker(1 * time.Second)
<-ticker.C
ticker.Stop()
```

有时间我们想无阻塞的发送或接收一个channel，可以使用带`default`分支的select语句。

channel的0值是nil, 这是非常有用的，因为nil channel上的发送和接收都会永久block, 因此select语句中case的channel如果是nil，那么就永远不会被选中。
这就使得我们可以用nil来控制一些超时错误处理或者取消处理的开关


#### 8.8 Example: Concurrent Directory Traversal


#### 8.9 Cancellation
没有方法来让一个goroutine直接结束另一个goroutine. 在之前的内容中，我们可以通过给一个abort的channel发送一个值来结束goroutine.
但是如果要结束2个goroutine呢？或者更多个goroutine呢？

考虑到channel的一个特性：一个已经关闭的且没有待接收元素的channel，后续的接收操作不会block，直接返回0值，
因此，我们可以这个特性来实现一个广播机制：不是向channel发送数据，而是关闭这个channel

```go
var done = make(chan struct{})

func cancelled() bool {
	select {
	case <-done:
		return true
	default:
		return false
	}
}
```
另外，创建一个goroutine来读取标准输入，当有任何值输入时，关闭这个channel
```go
go func() {
	os.Stdin.Read(make([]byte, 1))
	close(done)
}()
```
现在，需要让goroutines来回应这个cancellation.在main goroutine中，我们增加第三个case来试图从done中接收数据，
```go
for { 
	select {
         case <-done:
             // Drain fileSizes to allow existing goroutines to finish.
             for range fileSizes {
                 // Do nothing. 
             }
             return
         case size, ok := <-fileSizes:
            // ...
    }
}
```


### 第9章 Concurrency with Shared Variables

#### 9.1 Race Conditions
竞争条件指的是一种多个goroutine操作时程序无法给出正确结果的情形。往往在流量较大或者偶发的出现，难以复现和诊断

如何避免数据竞争？
+ 第一个方法是不要写变量，
+ 第二个方法就是避免多个goroutine同时访问一个变量，Go语言中"不要使用共享内存来通信，而是使用通信来共享内存"

一个接收channel请求来修个一个限定区域变量的代理goroutine称作这个变量的monitor goroutine.

+ 第三个方法就是允许多个goroutine访问变量，但不是在同一时刻


#### 9.2 Mutual Exclusion: sync.Mutex
8.6中可以通过一个累加器信号量来确保不超过20个goroutine被HTTP创建，同理，我们可以用一个capacity为1的channel来确保每次最多只有1个
goroutine来访问一个共享变量。

这种模式较为常用，因此，Go语言直接用`sync.Mutex`实现了这个逻辑
```go
import "sync"

var (
	mu sync.Mutex
	balance int
)

func Deposit(amount int) {
	mu.Lock()
	balance += amount
	mu.Unlock()
}

func Balance() int {
	mu.Lock()
	b := balance
	mu.Unlock()
	return b
}
```
在较为复杂的`critical section`中，可以使用`defer mu.Unlock()`来保证锁得到释放。

Go中的mutex是不可重入的，也就是不可以lock一个已经locked的mutex


#### 9.3 Read/Write Mutexes: sync.RWMutex
```go
var mu sync.RWMutex
var balance int
func Balance() int {
     mu.RLock() // readers lock
     defer mu.RUnlock()
     return balance
}
```
RLock用于获取读锁或者共享锁, 而Lock操作和sync.Mutex一样，用于获取互斥锁。

RWMutex适用于绝对大部分goroutine需要的都是读锁，锁会发生争用，也就是说，goroutine需要等待知道获取锁。


#### 9.4 Memory Synchronization
在现代计算机上，每个处理器的主存都有自己本地的缓存，为了效率，往内存的写入会被处理器先buffer住，在需要的时候才会刷往内存。
因此，这些写入的顺序可能是跟goroutine中顺序不同的。

考虑下面的代码：
```go
var x, y int
go func() {
	x = 1
	fmt.Print(y)
}()

go func() {
	y = 1
	fmt.Print(x)
}()
```
考虑到两个并行的函数，因此输出时不可预估的。
所有的并行问题都可以通过坚持使用简单的，确定的模式来解决。

如果可能，尽量将变量限制到一个goroutine中，对于其他变量，使用互斥


#### 9.5 Lazy Initialization: sync.Once
将一个比较昂贵的初始化步骤推迟到需要使用的时候执行往往是一个不错的实践。
```go
var icons map[string]image.Image

func loadIcons() {
    icons = map[string]image.Image{
         "spades.png":   loadIcon("spades.png"),
         "hearts.png":   loadIcon("hearts.png"),
     }
}

func Icon(name string) image.Image {
    if icons == nil {
    	loadIcons()
    }	
    return icons[name]
}
```
这样在单个goroutine中没有问题，但是，如果Icon函数被并行调用，可能会导致loadIcons()被多次调用，

Go提供了一次初始化的原语`sync.Once`,一个`Once`包含一个mutex以及一个bool变量来标识是否已经初始化了，
这个mutex来同时守卫bool变量和用户数据结构。`Once`只有1个方法`Do`, 接收初始化函数作为参数。
```go
var loadIconsOnce sync.Once
var icons map[string]image.Image

func Icon(name string) image.Image {
	loadIconsOnce.Do(loadIcon)
	return icons[name]
}
```
每次对`Do(loadIcon)`函数的调用都会锁住mutex, 并且检查bool变量。
第一次调用时，bool变量是false，`Do`会调用`loadIcons`，然后设置这个bool变量为true，
后续的调用将不会做任何事情，但是这中互斥同步保证了loadIcons对内存的修改对所有goroutine可见。


#### 9.6 The Race Detector
哪怕再精心设计，要完全避免并行错误还是很难的，幸运的是G提供了竞争检测器，只需要在`go build`, `go run`或者`go test`的时候加上
`-race`标识即可。


#### 9.8 Goroutines and Threads

##### 9.8.1 Growable Stacks
每个OS的线程都有一固定大小内存的栈，一般是2MB，用来存放函数调用的local variables或者当其他函数调用时临时挂起。
这个固定大小的栈即太大，又太小。对于一些需要消耗巨量内存的goroutine来说太小，比如说仅仅使用`waitGroup`然后关闭一个channel。

对于一个Go程序，创建上千个goroutine也不是什么不常见的情况，因此，这种固定大小的栈已经不适合了。
在Go中，一个goroutine以一个很小的栈开始，一般是2KB，一个goroutine栈，和线程一样，用来存放本地变量，挂起函数调用，但是，和线程不一样的是，
goroutine的栈大小是可变的，会根据需要增长或收缩。最大可到1GB


##### 9.8.2 Goroutine Scheduling
线程被OS kernel调度，每几毫秒，处理器都会被硬件定时器中断，然后触发一个叫做`schedule`的kernel function。
这个函数挂起当前正在执行的线程，保存内存中的寄存器，然后寻找下一个需要执行的线程，然后从寄存器中恢复线程，继续执行。

因为线程的切换需要完整的上线文切换，比较耗时，Go runtime拥有自己的调度器，使用了m:n调度机制。会在n个线程上调度m个goroutine.
Go调度器的作用就是模拟kernel调度器，但是仅仅只关心一个Go程序的goroutine

和被硬件时钟中断不同，Go语言是由一些语句隐式的调用的，比如，调用`time.Sleep`或者channel产生了block，或者mutex操作，
调度器都会将其休眠，然后运行其他的goroutine, 直到其被再次唤醒。由于不需要进行kernel上下文的切换，因此重新调用一个goroutine的消耗较小。

##### 9.8.3 GOMAXPROCS
Go调度器支持一个叫做`GOMAXPROCS`的参数来决定同时使用多少个线程来运行Go程序。默认值是CPU的个数
```go
GOMAXPROCS=2 go run hacker-client.go
```

##### 9.8.4 Goroutines Have No Identity
每个线程有一个唯一标识符，


### 第10章 Packages and the Go Tool
todo

### 第11章 测试
todo

### 第12章 反射
反射由reflect包提供支持，定义了2个重要的类型:`Type`和`Value`。
一个`Type`表示一个Go类型，它是一个接口，唯一能反映reflect.Type实现的是接口的类型描述信息
```go
t := reflect.TypeOf(3)      // a reflect.Type
fmt.Println(t.String())     // "int"
fmt.Println(t)              // "int"
```

`reflect.TypeOf`返回的是一个动态类型的接口值，它总是返回具体的类型。因此，
```go
var w io.Writer = os.Stdout
fmt.Println(reflect.Type(w))    // "*.os.File"
```
这里返回的是`*os.File`，而不是`io.Writer`

另外一个类型是`Value`， 一个`reflect.Value`可以持有一个任意类型的值，
函数`reflect.ValueOf`接受任意的`interface{}`类型，并返回对应动态类型的`reflect.Value`，返回的结果是对应于具体类型

调用Value的`Type`方法将返回具体类型所对应的`reflect.Type`
```go
v := reflect.ValueOf(3)
fmt.Println(v)      // "3"
fmt.Printf("%v\n", v)   // "3"
fmt.Println(v.String()) // "<int Value>"

t := v.Type()
fmt.Println(t.String()) // "int"
```

可以调用`relect.ValueOf.Interface`的方法来进行逆操作，它返回一个`interface{}`类型表示`reflect.Value`对应类型的具体值
```go
v := reflect.ValueOf(3) // a reflect.Value
x := v.Interface()  // a interface{}
i := x.(int)    // assertion, int
fmt.Printf("%d\n", i)   // "3"
```




