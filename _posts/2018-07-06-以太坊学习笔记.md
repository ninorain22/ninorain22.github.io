---
layout: post
title: 以太坊学习笔记
date: 2018-07-06 11:35:00.000000000 +09:00
---

以太坊的目的是基于脚本、竞争币和链上元协议概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、特性完备的、易于开发和协同的应用

#### 以太坊账户
在以太坊系统中，状态是由被称为账户（由一个20字节的地址）对象和在两个账户之间的转移价值和信息的状态构成的。以太坊的账户包括四个部分：
+ 随机数，用于确定每笔交易只能被处理一次的计数器
+ 账户目前的以太币余额
+ 账户的合约代码
+ 账户的存储（默认为空）

一般，以太坊由两种类型的账户：外部所有的账户（由私钥控制）和合约账户（由合约代码控制）。
外部所有的账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取和写入、发送其他消息或者创建合约

#### 消息和交易
对比与比特币交易，两者的三点不同：
+ 以太坊的消息可以由外部实体或者合约创建，而比特币的交易只能从外部创建
+ 以太坊消息可以选择包含数据
+ 如果以太坊消息的接收者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念

#### 代码执行
以太坊合约的代码使用低级的基于堆栈的字节码的语言携程，称为EVM代码。
一般而言，代码执行是无限循环，程序计数器每增加一，就执行一次操作，直到代码执行完毕或遇到错误，``STOP``或``RETURN``命令。操作可以访问三种存储数据的空间：
+ 堆栈：32字节的数值可以入栈、出栈
+ 内存，可无限扩展的字节队列
+ 合约的长期存储，一个秘钥/数值的存储，其中秘钥和数值都是32字节，存储内容将长期保持

代码可以向区块头数据一样访问数值、发送者和接收到的消息中的数据，代码还可以返回数据的字节队列作为输出。

#### 应用
一般来说，以太坊之上有三种应用。
+ 金融应用，为用户提供更强大的用他们的钱管理和参与合约的方法，包括子货币、金融衍生品、对冲合约、储蓄钱包、遗嘱等
+ 半金融应用，例如为解决计算问题而设的自我强制悬赏
+ 非金融应用，比如在线投票和去中心化治理


### Solidity

在Solidity中，一个合约由一组代码（合约的函数）和数据（合约的状态）组成，合约位于以太坊区块链上的一个特殊地址。

#### 交易
一笔交易是一条消息，从一个账户发送到另一个账户，交易可以包含二进制数据（payload）和以太币。
+ 如果目标账户包含代码，该代码会执行，payload就是输入数据
+ 如果目标账户是零账户（账户地址是0），交易将创建一个新合约。这个合约地址不是零地址，而是由合约创建者的地址和该地址发出过的交易数量(nonce)计算得到的。
创建合约交易的payload被当做EVM字节码执行，执行的输出作为合约代码被永久存储，意味着，为了创建一个合约，你不需要向合约发送真正的合约代码，而是发送能够返回真正代码的代码。

#### 存储、主存和栈
+ 每个账户有一块持久化的内存区域被称为存储（storage），形式为key-value，key和value的长度均为256bits。
在合约里，不能遍历账户的存储。读存储的相对开销很高，修改存储的开销更高，合约智能读写存储区内属于自己的部分。
+ 第二个内存区被称为内存（memory），合约执行每次消息调用时，都有一块新的，被清除过的主存。
主存可以以字节粒度寻址，但是读写粒度为32字节（256bits），写的粒度可以是8bits或者256bits。
当访问从未访问过的内存字时，内存将按字（每个字256位）扩展，扩展将消耗一定的gas，且随着内存增长，消耗的gas量也会增高
+ EVM不是基于寄存器，而是基于栈的虚拟机。因此所有的计算都在一个被称为栈（stack）的区域执行。栈最大有1024个元素，每个元素256bits。


### Solidity官方文档
Solidity是静态类型语言，支持继承、库和复杂的用户定义类型等特性
目前最好的Solidity编程方式是用Remix，Remix是一个基于Web浏览器的IDE，可以编写Solidity并部署运行

#### 合约结构

##### 状态变量
状态变量是永久存储在合约中的值
```solidity
pragma solidity ^0.4.0;

contract SimpleStorage {
    uint storedData; // 状态变量
    // ...
}
```

##### 函数
代码中的可执行单元
```solidity
pragma solidity ^0.4.0;

contract SimpleAuction {
    function bid() public payable { // 函数
        // ...
    }
}
```

##### 函数修饰器
以声明的方式来改良函数语义
```solidity
pragma solidity ^0.4.22;

contract Purchase {
    address public seller;

    modifier onlySeller() { // 修饰器
        require(
            msg.sender == seller,
            "Only seller can call this."
        );
        _;
    }

    function abort() public onlySeller { // Modifier usage
        // ...
    }
}
```

##### 事件
事件是以太坊虚拟机日志工具的方便接口
```solidity
pragma solidity ^0.4.21;
contract SimpleAuction {
    event HighestBidIncreased(address bidder, uint amount); // 事件

    function bid() public payable {
        // ...
        emit HighestBidIncreased(msg.sender, msg.value); // 触发事件
    }
}
```

##### 结构类型
将几个变量分组的自定义类型
```solidity
pragma solidity ^0.4.0;

contract Ballot {
    struct Voter { // 结构
        uint weight;
        bool voted;
        address delegate;
        uint vote;
    }
}
```

##### 枚举类型
由一定数量的常量值构成的自定义类型
```solidity
pragma solidity ^0.4.0;

contract Purchase {
    enum State { Created, Locked, Inactive } // 枚举
}
```

#### 类型
##### 值类型
+ 布尔类型bool: true或false
+ 整型int/uint(8~256)
+ 定长浮点型fixd/ufixed:暂未完全支持

##### 地址类型
address：一个20字节的值，下面是地址类型的成员变量：
+ balance和transfer：balance是一个地址的余额，transfer用来向一个地址发送以太币
```solidity
address x = 0x123;
address myAddress = this;
if (x.balance < 10 && myAddress.balance >= 10) x.transfer(10);
```
如果X是一个合约地址，它的代码会跟transfer函数调用一起执行。如果在执行过程中用光了gas，以太币交易就会被打回，合约会在终止的同时抛出异常。

+ send：transfer的低级版本，如果执行失败，合约不会因为异常而终止，但send会返回false。目前不推荐使用。
+ call、callcode和delegatecall：为了与不符合应用二进制接口的合约交互，就有了可以接受任意数量参数的call函数，这些参数会被打包到以32字节为单位的连续区域中存放。
其中一个例外是第一个参数正好被编码为4个字节的情况，这种情况下参数后面不会填充后续参数编码。

call返回的布尔值表明了被调用的函数已经执行完毕（true）或者引发了一个EVM异常（false）,无法访问返回的真实数据。

可以使用.gas()修饰器调整提供的gas数量：
```solidity
nameReg.call.gas(1000)("register", "myName");
```
类似的，也能控制以太币的数量:
```solidity
nameReg.call.value(1 ether)("register", "myName");
```
修饰符可以联用，顺序不重要
```solidity
nameReg.call.value(1 ether).gas(10000)("register", "myName");
```

类似的，也可以使用delegatecall，区别在于只使用给定地址的代码。

call、delegatecall和callcode都是非常低级的函数，破坏了Solidity的安全性，不建议使用。

##### 定长字节数组
bytes1，bytes2..... bytes32

``.length``代表了字节数组的长度。

##### 变长字节数组
+ bytes
+ string

##### 地址字面常数

##### 有理数和整数字面常数
Solidity中没有八进制，所以前置0是无效的

##### 字符串字面长度
和C语言不同，字符串后面没有结束符。"foo"的长度是3而不是4

##### 十六进制字面常数
以关键字hex开头，``hex"001122F""``

#### 函数类型
```solidity
function (<parameter types>) {internal|external} {pure|constant|view|payable} [returns (<return types>)]
```
如果不需要返回，删除整个[returns]部分
函数分为内部（internal)和外部（external）两种类型。

函数类型默认是内部函数，因此不需要声明internal关键字。
与此相反的是，合约中的函数本身默认是public的，只有当它被当做类型名称时，默认才是内部函数

public函数有一个特殊的成员变量，称作selector，可以返回ABI函数选择器。
```solidity
pragma solidity ^0.4.22;
contract Selector {
    function f() public view returns (bytes4) {
        return this.f.selector;
    }
}

```

外部函数使用的例子：
```solidity
pragma solidity ^0.4.11;

contract Oracle {
  struct Request {
    bytes data;
    function(bytes memory) external callback;
  }
  Request[] requests;
  event NewRequest(uint);
  function query(bytes data, function(bytes memory) external callback) public {
    requests.push(Request(data, callback));
    NewRequest(requests.length - 1);
  }
  function reply(uint requestID, bytes response) public {
    // 这里要验证 reply 来自可信的源
    requests[requestID].callback(response);
  }
}

contract OracleUser {
  Oracle constant oracle = Oracle(0x1234567); // 已知的合约
  function buySomething() {
    oracle.query("USD", this.oracleResponse);
  }
  function oracleResponse(bytes response) public {
    require(msg.sender == address(oracle));
    // 使用数据
  }
}
```

内部函数使用的例子：
```solidity
pragma solidity ^0.4.16;

library ArrayUtils {
  // 内部函数可以在内部库函数中使用，
  // 因为它们会成为同一代码上下文的一部分
  function map(uint[] memory self, function (uint) pure returns (uint) f)
    internal
    pure
    returns (uint[] memory r)
  {
    r = new uint[](self.length);
    for (uint i = 0; i < self.length; i++) {
      r[i] = f(self[i]);
    }
  }
  function reduce(
    uint[] memory self,
    function (uint, uint) pure returns (uint) f
  )
    internal
    pure
    returns (uint r)
  {
    r = self[0];
    for (uint i = 1; i < self.length; i++) {
      r = f(r, self[i]);
    }
  }
  function range(uint length) internal pure returns (uint[] memory r) {
    r = new uint[](length);
    for (uint i = 0; i < r.length; i++) {
      r[i] = i;
    }
  }
}

contract Pyramid {
  using ArrayUtils for *;
  function pyramid(uint l) public pure returns (uint) {
    return ArrayUtils.range(l).map(square).reduce(sum);
  }
  function square(uint x) internal pure returns (uint) {
    return x * x;
  }
  function sum(uint x, uint y) internal pure returns (uint) {
    return x + y;
  }
}
```

#### 引用类型
在处理占位空间超过256bit的类型时，因为拷贝的开销过大，我们需要考虑是存放在内存（memory）中还是存储（storage）中

##### 数据位置
所有复杂类型，数组和结构类型，都有个额外属性：数据位置。大多数都有默认的存储位置。但也可以在类型名后添加``memory``或``storage``修改。
+ 函数的默认位置是``memory``
+ 局部变量的默认位置是``storage``
+ 状态变量的数据位置强制是``storage``