## 1.4 Linux内核和传统Unix内核的比较

+ Linux支持动态加载内核模块
+ Linux支持对称多处理（SMP）机制
+ Linux内核可以抢占。Linux内核允许在内核运行的任务优先执行
+ Linux内核并不区分线程和一般进程
+ Linux提供具有设备类的面向对象的设备模型、热插拔时间，以及用户空间的设备文件系统(sysfs)
+ Linux忽略了STEAMS等特性

### 2.4.6 同步和并发
内核容易产生竞争条件，因此内核许多特性都要求能够并发访问共享数据，特别是：
+ Linux是抢占多任务操作系统。内核的进程调度即兴对进程进行调度和重新调度。内核必须和这些任务同步
+ Linux内核支持对称多处理系统（SMP），因此在两个以上处理器上执行的内核代码很可能会同时访问一个共享资源
+ 中断处理程序有可能访问同一资源
+ Linux内核可以抢占

常见解决竞争的办法是**自旋锁**和**信号量**


# 进程管理

## 3.1 进程
在Linux中，进程通常是fork()的结果，该系统调用复制一个现有进程来创建另一个进程

## 3.2 进程描述符及任务结构
内核把进程的列表存放在任务队列的**双向循环链表**中。链表的每一项都是类型为``task_struct``的进程描述符结构

### 3.2.1 分配进程描述符
Linux通过slab分配器分配``task_struct``结构。

### 3.2.2 进程描述符的存放
内核通过一个唯一的进程标识值或PID来标识每个进程。PID是一个数，表示为``pid_t``隐含类型，实际上是一个``int``类型

### 3.2.3 进程状态
系统中每个进程必然处于下面5种状态之一：
+ TASK_RUNNING(运行)：进程是可执行的，或者正在执行，或在运行队列种等待执行。这是进程在用户空间中执行的唯一可能的状态；这种状态也可以应用到内核空间中正在执行的进程
+ TASK_INTERRUPTIBLE(可中断)：进程正在睡眠（被阻塞）