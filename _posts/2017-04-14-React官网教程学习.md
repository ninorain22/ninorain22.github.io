---
layout: post
title: React官网教程学习
tags:
- React
date: 2017-04-14 17:00:00.000000000 +09:00
---

### 组合组件

```js
var CommentList = React.createClass({
  render: function() {
    return (
      <div className="commentList">
        Hello, world! I am a CommentList.
      </div>
    );
  }
});

var CommentForm = React.createClass({
  render: function() {
    return (
      <div className="commentForm">
        Hello, world! I am a CommentForm.
      </div>
    );
  }
});

var CommentBox = React.createClass({
  render: function() {
    return (
      <div className="commentBox">
        <h1>Comments</h1>
        <CommentList />
        <CommentForm />
      </div>
    );
  }
});
```

### 使用props

```js
var Comment = React.createClass({
  render: function() {
    return (
      <div className="comment">
        <h2 className="commentAuthor">
          {this.props.author}
        </h2>
        {this.props.children}
      </div>
    );
  }
});
```

### 组件的属性
```js
var CommentList = React.createClass({
  render: function() {
    return (
      <div className="commentList">
        <Comment author="Pete Hunt">This is one comment</Comment>
        <Comment author="Jordan Walke">This is *another* comment</Comment>
      </div>
    );
  }
});
```

### 挂钩数据模型
```js
var data = [
    {id: 1, author: "Pete Hunt", text: "This is one comment"},
    {id: 2, author: "Jordan Walke", text: "This is *another* comment"}
];

var CommentBox = React.createClass({
  render: function() {
    return (
      <div className="commentBox">
        <h1>Comments</h1>
        <CommentList data={this.props.data} />
        <CommentForm />
      </div>
    );
  }
});

ReactDOM.render(
  <CommentBox data={data} />,
  document.getElementById('content')
);
```

```js
var CommentList = React.createClass({
  render: function() {
    var commentNodes = this.props.data.map(function(comment) {
      return (
        <Comment author={comment.author} key={comment.id}>
          {comment.text}
        </Comment>
      );
    });
    return (
      <div className="commentList">
        {commentNodes}
      </div>
    );
  }
});
```

### Reactive state
``props``是不可变的：它们从父级传来并被父级“拥有”
为了实现交互，我们给组件引进了可变的**state**, ``this.state``是组件私有的，可以用``this.setState()``来改变它，每当state更新，组件就重新渲染自己

```js
var CommentBox = React.createClass({
  getInitialState: function() {
    return {data: []};
  },
  render: function() {
    return (
      <div className="commentBox">
        <h1>Comments</h1>
        <CommentList data={this.state.data} />
        <CommentForm />
      </div>
    );
  }
});    
```

``getInitialState()``在生命周期里只执行1次

#### 更新状态
```js
var CommentBox = React.createClass({
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    $.ajax({
      url: this.props.url,
      dataType: 'json',
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  render: function() {
    return (
      <div className="commentBox">
        <h1>Comments</h1>
        <CommentList data={this.state.data} />
        <CommentForm />
      </div>
    );
  }
});
```

``componentDidMount()``是一个当**组件被渲染时**被Ｒeact自动调用的方法，动态更新的关键是对``this.setState()``的调用

### 添加新评论
```js
var CommentForm = React.createClass({
  getInitialState: function() {
    return {author: '', text: ''};
  },
  handleAuthorChange: function(e) {
    this.setState({author: e.target.value});
  },
  handleTextChange: function(e) {
    this.setState({text: e.target.value});
  },
  handleSubmit: function(e) {
      e.preventDefault();
      var author = this.state.author.trim();
      var text = this.state.text.trim();
      if (!text || !author) {
        return;
      }
      this.props.onCommentSubmit({author: author, text: text});
      this.setState({author: '', text: ''});
    },
  render: function() {
    return (
      <form className="commentForm" onSubmit={this.handleSubmit}>
        <input
          type="text"
          placeholder="Your name"
          value={this.state.author}
          onChange={this.handleAuthorChange}
        />
        <input
          type="text"
          placeholder="Say something..."
          value={this.state.text}
          onChange={this.handleTextChange}
        />
        <input type="submit" value="Post" />
      </form>
    );
  }
});
```
在事件中调用preventDefault()来阻止浏览器提交表单的默认行为
```js
var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: 'json',
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  handleCommentSubmit: function(comment) {
    var comments = this.state.data;
        // Optimistically set an id on the new comment. It will be replaced by an
        // id generated by the server. In a production application you would likely
        // not use Date.now() for this and would have a more robust system in place.
    comment.id = Date.now();
    var newComments = comments.concat([comment]);
    this.setState({data: newComments});
    $.ajax({
      url: this.props.url,
      dataType: 'json',
      type: 'POST',
      data: comment,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        this.setState({data: comments});
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      <div className="commentBox">
        <h1>Comments</h1>
        <CommentList data={this.state.data} />
        <CommentForm onCommentSubmit={this.handleCommentSubmit} />
      </div>
    );
  }
});
```

## React编程思想
---
### 把UI拆分为一个组件的层级
一个组件在理想情况下只做一件事情。如果它最终增长了，它就应该被分解为更小的组件

### React创建一个静态版本

### 确定最小（但完备）的 UI state 表达 
要正确的构建你的 app，你首先需要思考你的 app 需要的可变 state 的最小组
这里的关键是 DRY 原则：**Don't Repeat Yourself(不要重复自己)**
例如，不要为了计数保持一个单独的 state 变量。当你想渲染 TODO 的计数时，简单的采用 TODO 项目的数组长度作为替代
逐一检查state:
+ 它是通过props从父级传递来的吗？如果是，它可能不是 state
+ 它随时间变化吗？如果不是,它可能不是 state
+ 你能基于其他任何组件里的 state 或者 props 计算出它吗？如果是,它可能不是state

### 确定你的 state 应该存在于哪里
React 总是在组件层级中单向数据流动的。可能不能立刻明白哪些组件应该拥有哪些 state
对于你的应用里每一个数据块:
+ 确定哪些组件要基于 state 来渲染内容
+ 找到一个共同的拥有者组件（在所有需要这个state组件的层次之上，找出共有的单一组件）
+ 要么是共同拥有者，要么是其他在层级里更高级的组件应该拥有这个state
+ 如果你不能找到一个组件让其可以有意义地拥有这个 state，可以简单地创建一个新的组件 hold 住这个state，并把它添加到比共同拥有者组件更高的层级上

### 添加反向数据流

## Guide
---

### 动态交互式用户界面
#### 组件其实是状态机
React 把用户界面当作简单状态机。把用户界面想像成拥有不同状态然后渲染这些状态，可以轻松让用户界面和数据保持一致。
React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。React 来决定如何最高效地更新 DOM

#### 哪些组件应该有 State？
大部分组件的工作应该是从 props 里取数据并渲染出来。
但是，有时需要对用户输入、服务器请求或者时间变化等作出响应，这时才需要使用 State
**尝试把尽可能多的组件无状态化**
常用的模式是创建多个只负责渲染数据的无状态（stateless）组件，在它们的上层创建一个有状态（stateful）组件并把它的状态通过 props 传给子级

#### 哪些应该作为 State？
State 应该包括那些可能被组件的事件处理器改变并触发用户界面更新的数据

#### 哪些 不应该 作为 State？
this.state 应该仅包括能表示用户界面状态所需的最少数据。因此，它不应该包括：
+ 计算所得数据
+ React 组件
+ 基于 props 的重复数据

### 复合组件




