## 第二部分 开发篇

### 第7章 表类型
5.5后默认InnoDB

##### 7.2.2 InnoDB

1. 自动增长列
对于InnoDB, 自动增长列必须是索引，如果是组合索引，必须是组合索引的第一项。

2. 外键约束
MySQL支持外键约束的只有InnoDB, 创建外键时，父表必须有对应的索引，子表在创建外键时也会自动创建对应索引

3. 存储方式
InnoDB存储表和索引有以下两种方式
+ 使用共享表空间存储，这种方式创建的表结构保存在.frm文件中，数据和索引保存在`innodb_data_home_dir`和`innodb_data_file_path`定义的表空间中，可以是多个文件。
+ 使用多表空间存储，表结构在.frm文件中，但是每个表的数据和索引单独保存在`.ibd`中。
如果是分区表，则每个分度对应单独的`.ibd`文件，文件名是`表名+分区名`，可以在创建分区的时候指定每个分区的数据文件的位置，以此来将表的IO均匀分布在多个磁盘上。


#### 7.3 如何选择合适的存储引擎
InnoDB：用于事务处理应用程序，对事务的完整性有较高要求，在并发时要求数据一致性，那么可以选择InnoDB, InnoDB除了有效的降低由于更新和删除导致的锁定，
还可以确保事务的完整提交和回滚。

### 第8章 选择合适的数据类型

#### 8.1 CHAR和VARCHAR
CHAR属于固定长度的字符类型，VARCHAR属于可变长度的字符类型

检索时，CHAR列删除了尾部的空格，优点是由于长度固定，所以处理速度快，去诶单是浪费存储空间，程序需要处理尾部空格。

在InnoDB中，建议使用过VARCHAR类型，因为内部的行存储格式并没有区分固定长度和可变长度的列，因此，本质上，使用CHAR的性能不一定要优于使用VARCHAR。
主要的性能因素是数据行使用的存储总量，所以使用占用空间较小的VARCHAR比较好

#### 8.2 TEXT和BLOB
TEXT只能保存字符串，BLOB能用来保存二进制数据，比如图片等。
+ BLOB和TEXT都会引起一些性能问题，特别是执行了大量的删除操作时，会在数据表中留下很大的空洞，以后填入这些空洞的记录在插入的性能上会有影响。
因此，建议定期使用`OPTIMIZE TABLE`功能对这类表进行碎片整理。
+ 可以使用合成的索引来提高大文本字段(BLOB或TEXT)的查询性能。就是为大文本字段内容建立一个散列值，并单独存储到一列中，
+ 在不必要的时候避免检索大型的BLOB或TEXT值
+ 把BLOB或TEXT列分离到单独的表中

#### 8.3 浮点数和定点数
浮点数 float, double，插入数据如果精度超过定义精度，自动四舍五入
定点数 decimal,实际以字符串形式存放

在精度要求较高的应用中，使用定点数而不是浮点数，因为浮点数会有精度的误差。

#### 8.4 日期类型选择
DATE, TIME, DATETIME, TIMESTAMP
如果要记录年份较久远，最好使用DATETIME，因为TIMESTAMP表示的日期范围要短
如果记录的日期要让不同时区的用户使用，最好使用TIMESTAMP, 只有它能和实际时区对应


### 第9章 字符集

#### 9.4 选择合适的字符集
+ 满足应用支持语言的需求，如果需要处理各种文字，或者发布到不用语言的地区，选择UTF-8
+ 如果应用中涉及已有数据的导入，需要考虑字符集对已有数据的兼容性。比如已有数据是GBK文字，如果选择GB2312-80位字符集，那么久会出现某些文字无法导入
+ 如果数据库只需要支持一般中文，且数据量大，性能要求高，那么就可以选择双字节定长编码的GBK，这样比UTF-8的汉字编码要少1个字节（GBK汉字2个字节，UTF8汉字3个字节）
+ 如果需要做大量的字符运算，比如比较、排序等，那么优先选择定长字符集，处理速度更快
+ 如果客户端程序都支持相同的字符集，那么优先选择该字符集避免因为字符集转换带来的开销和数据损失

#### 9.5 MySQL支持的字符集
MYSQL字符集包括字符集(CHARACTER)和校对规则(COLLATION)2个概念。
其中字符集用来定义MYSQL存储字符串的方式，校对规则用来定义比较字符串的方式。

每个字符集至少对应1个校对规则。校对规则命名约定：
相关字符集名 + 语言名 + _ci(大小写不敏感) | _cs(大小写敏感) | _bin(基于字符串编码值比较)


### 第10章 索引的设计和使用

#### 10.1 索引概述
每种存储引擎对每个表支持至少16个索引，总索引长度至少为256字节。

InnoDB的表默认创建的是BTREE索引，也支持前缀索引，即对索引字段的前N个字符创建索引。InnoDB中，索引前缀长度最长767字节。

#### 10.2 设计索引的原则
+ 搜索的索引列，不一定是所要选择的列。也就是说最合适索引的列式出现在WHERE子句中的列，或链接字句中的列，而不是出现在SELECT关键字后的选择列表中的列
+ 使用唯一索引，考虑值的分布，索引的列的基数越大，索引效果就越好。
+ 使用短索引，如果对字符串列进行索引，指定一个前缀长度，比如一个CHAR(200)的列，前缀取10~20个字符即可
+ 利用最左前缀，在创建一个n列的索引时，实际上是创建了MYSQL可利用的n个索引，多列索引可起几个索引的作用，利用索引中最左边的列集来匹配行
+ 不要过度索引，每个额外的索引都要占用额外的磁盘空间，降低写性能。MYSQL在生成一个执行计划时，会对索引进行考虑，如果索引需要花费工作太多，可能就选择不到最好的索引。
+ 对于InnoDB的表，记录默认按照一定顺序保存，如果有明确的主键，按照主键顺序保存，如果没有主键，但是有唯一索引，那么按照唯一索引顺序保存，否则，表中会自动生成一个内部列，按照这个列的顺序保存。
按照主键或者内部列的访问时最快的，所以InnoDB尽量自己指定主键，提高查询效率。另外，InnoDB的普通索引都会保存主键的键值，因此，主键需要尽可能短的数据类型，减少索引的磁盘占用，
提高索引缓存效果

#### BTREE索引与HASH索引
HASH索引一些特征如下：
+ 只用于 = 或 <=> 操作符的等式比较
+ 优化器不能使用HASH索引来加速ORDER BY操作
+ MYSQL不能确定两个值之间的行数，如果将一个MYISAM表改为HASH索引的MEMORY表，会影响查询效率
+ 只能使用整个关键字来搜索一行

而BTREE索引，使用>, <, >=, <=, BETWEEMN, !=或者<>, LIKE `pattern`时(pattern不是通配符开头)，都可以使用相关列上的索引


### 第14章 事务控制和锁定语句

MYSQL支持对InnoDB的表进行行级锁定


#### 14.3 分布式事务的使用
分布式事务只支持InnoDB

##### 14.3.1 分布式事务的原理
在MYSQL中，分布式事务设计一个或多个资源管理器，以及一个事务管理器
+ 资源管理器(RM)，用于提供通向事务资源的途径，数据库服务器就是一种资源管理器，该管理器必须可以提交或者回滚由资源管理器管理的事务，
比如多台MYSQL数据库作为多台资源管理器
+ 事务管理器(TM)，用于协调作为一个分布式事务一部分的事务。事务管理器与管理每个事务的资源管理器进行通信。在一个分布式事务中，
各个单个事务都是分布式事务的分支事务。

MYSQL执行XA MYSQL时，MYSQL服务器相当于一个用于管理分布式事务中的XA事务的资源管理器，与MYSQL连接的客户端相当于事务管理器

要执行一个分布式事务，必须要知道这个事务涉及了哪些资源管理器，并且把每个资源管理器的事务执行到事务被提交或者回滚。

用于执行分布式事务的过程使用`两阶段提交`，发生时间在由分布式事务的各个分支需要进行的行动已经被执行后
+ 第一阶段，所有分支被预备好，即它们被TM告知要准备提交。意味着用于管理分支的每个RM会记录对于被稳定保存的分支的行动，分支指示是否它们可以这么做，
结果被用于第二阶段
+ 第二阶段，TM告知RMs是否要提交或回滚，如果在预备分支时，所有分支指示它们能够提交，则所有的分支被告知要提交。
如果在预备时，有任何分支指示不能提交，则所有分支被告知回滚


### 第17章 MySQL分区
根据一定规则，将一个表分解成多个更小的，容易管理的部分，对业务逻辑透明。

分区的优点：
+ 存储更多数据
+ 优化查询，在WHERE子句中包含分区条件时，可以只扫描必要的一个或多个分区来提高查询效率；同时在涉及SUM和COUNT聚合函数的查询时，可以容易的在分区上并行
+ 对于已经过期或者不需要保存的数据，可以通过删除与这些数据有关的分区来快速删除
+ 跨多个磁盘来分散数查询，获取更大查询吞吐量

使用ENGINE子句来设置分区。
```
ENGINE=INNODB
PARTITION BY HASH(MONTH(birth_date))
PARTITION 6
```

#### 17.2 分区类型
+ RANGE分区：基于一个给定的连续区间范围，将数据分配到不同分区
+ LIST分区：类似RANGE分区，区别是LIST分区是基于枚举值，RANGE分区基于范围值
+ HASH分区：基于给定的分区个数，哈希到不同分区
+ KEY分区：类似HASH分区

无论哪种分区类型，要么分区表上没有主键/唯一键，要么分区表的主键/唯一键必须包含分区键，
也就是说不能使用主键/唯一键字段之外的其他字段分区

Columns分区支持了多种类型：
+ 所有整数类型
+ 日期时间类型, data和dtetime
+ 字符类型，不支持text和blob


### 第18章 SQL优化

#### 18.1 优化SQL语句的一般步骤

##### 18.1.1 通过show status了解各种SQL执行效率
`show status like 'com_%'`
com_xxx表示每个xxx语句执行的次数，比较关心的是：
+ Com_select
+ Com_insert
+ Com_update
+ Com_delete
针对InnoDB，还会有如下几个操作统计
+ Innodb_rows_read: SELECT查询返回的行数
+ Innodb_rows_inserted
+ Innodb_rows_updated
+ Innodb_rows_deleted

这样很容易了解当前数据库是以插入更新为主还是以查询为主。

对于事务型应用，通过Com_commit和Com_rollback了解事务提交和回滚情况，对于回滚非常频繁的数据库，可能意味着应用编写有问题

##### 18.1.2 定位执行效率较低的SQL语句
+ 通过慢日志查询
+ 慢日志查询在查询结束以后才记录，不能实时定位问题。可以使用show processlist来查看当前MYSQL正在进行的线程，包括状态，是否锁表等

##### 18.1.3 通过EXPLAIN分析低效SQL的执行计划
给出的结果字段如下：
+ select_type: SELECT的类型，常见取值有SIMPLE(简单表，不使用连接或者子查询)、PRIMARY(主查询，即外层的查询)、UNION(UNION中第二个或后面的查询语句)、
SUBQUERY(子查询中的第一个SELECT)等
+ table: 输出结果集的表
+ type: MYSQL在表中找到所需行的方式，或者叫访问类型，常见类型如下：
    + ALL: 全表扫描
    + index: 索引全扫描，遍历整个索引来查询匹配的行
    + range：索引范围扫描，常见于<，>, between等操作
    + ref: 使用非唯一索引扫描或者唯一索引的前缀扫描，返回匹配某个单独值的记录行
    + eq_ref: 类似ref, 区别是使用的索引是唯一索引，对于每个索引键值，表中只有1条记录匹配，简单来说，就是多表连接中使用primary key或unique index作为了关联条件
    + const/system: 单表中最多有一行匹配，查询起来非常迅速，所以这个匹配行中的其他列的值看，而已被优化器在当前查询中当做常量来处理，比如根据主键或者唯一索引进行的查询
    + NULL: 不用访问表或者索引，直接能得到结果
+ possible_keys: 表示查询时可能使用的索引
+ key: 表示实际使用的索引
+ ken_len: 使用到索引字段的长度
+ rows: 扫描行的数量
+ Extra: 执行情况的说明和描述

使用`explain extended`命令，然后使用`show warnings`可以看到SQL在被真正执行之前做了哪些改写.
结果中多了filtered字段，同时，warning的message字段可以看到优化器最终改写的SQL。

有时候，仅通过explain并不能快速定位SQL的问题。需要选择profile联合分析

##### 18.1.4 通过show profile分析SQL
通过show profile for query [queryID]可以看到执行过程中的每个状态和消耗时间

##### 18.1.5 通过trace分析优化器如何选择执行计划
MySQL5.6提供了对SQL的跟踪。使用方式：
首先打开trace, 设置为JSON格式，设置最大使用的内存大小；
```
SET OPTIMIZER_TRACE="enabled=on", END_MARKERS_IN_JSON=on;
SET OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;
```
然后执行要trace的SQL语句；
最后检查`INFORMATION_SCHEMA.OPTIMIZER_TRACE`表就可以知道是如何执行SQL的


#### 18.2 索引问题

##### 18.2.1 索引的存储分类
MYSQL目前提供了4种索引：
1. BTREE索引，最常见的索引类型，大部分引擎都支持
2. HASH索引，只有Memory引擎支持
3. RTREE索引，MyISAM的一种特殊索引类型
4. Full-text索引，全文索引，InndDB从5.6开始支持

##### 18.2.2 MYSQL如何使用索引
以最常见的BTREE为例。BTREE即平衡树。并不是二叉树。

1. MYSQL中能够使用索引的典型场景
+ 匹配全值，对索引中所有列都指定具体值
+ 匹配值的范围查询，对索引的值能够进行范围查找
+ 匹配最左前缀，仅仅使用索引中最左边列进行查找，是BTREE索引使用的首要原则
比如创建(col1, col2, col3)的联合索引，可以被包含(col1), (col1, col2), (col1, col2, col3)的等值查询到，但是不能被(col2), (col2, col3)的等值查询到
+ 仅仅对索引进行查询，当查询的列都在索引的字段中时，查询的效率更高。Extra字段会变成`Using index`，表明仅仅通过索引就可以获得所需要的所有数据，不需要通过索引回表再去获取其他列值
+ 匹配列前缀，仅仅使用索引的第一列，并且只包含索引第一列的开头一部分进行查找，Extra字段是`Using where`表优化器需要通过索引回表查询数据
+ 能够实现索引匹配部分精确而其他部分进行范围查找
+ 如果列名是索引，那么使用column_name is null就会使用索引
+ MySQL5.6引入了Index Condition Pushdown特性，进一步优化了查询。可以让某些情况下的条件过滤操作下放到存储引擎

2. 存在索引单不能使用索引的典型场景
// todo@2019-06-06