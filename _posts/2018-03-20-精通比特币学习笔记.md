---
layout: post
title: 精通比特币学习笔记
date: 2018-03-20 14:30:00.000000000 +09:00
---

## 第1章 介绍
---

### 1.1 什么是比特币
比特币是一个分布式的点对点网络系统，因此没有中央服务器，也没有中央控制点。比特币是通过一个名为"挖矿"的过程产生的，挖矿需要在处理比特币交易的同时参与竞赛来解决一个数学问题。

在比特币网络的任何参与者都是潜在的矿工。每隔10分钟，有人能够验证过去10分钟发生的交易，作为回报，将会获得新的比特币。

比特币协议包括了内置算法，该算法可以调节网络中的挖矿能力。矿工必须完成的任务——在比特币网络中成功的记录一个区块交易——的难度是在动态调整的。因此，无论多少人在同时挖矿，通常每10分钟就有人成功。

比特币由这些构成：
+ 一个去中心化的点对点网络(比特币协议)
+ 一个公共的交易账簿(区块链)
+ 一个去中心化的数学和确定的货币发型(分布式挖矿)
+ 一个去中心化的交易验证系统(交易脚本)


### 1.2 比特币发展史


### 1.3 比特币的应用、用户和他们的故事


### 1.4 入门
比特币客户端的三种主要形式是:
+ 完整客户端：或称"全节点"，是存储所有比特币交易的整个交易历史的客户端，管理用户的钱包，并可以在比特币网络上直接开始交易。
+ 轻量级客户端：存储用户的钱包，但需要依赖第三方服务器才能进行比特币交易，才能接入比特币网络。轻量级客户端不保存所有交易的完整副本，因此必须信赖第三方的服务器获取交易确认。
+ 在线客户端：完全依赖于第三方服务器
+ 移动客户端：多种类型均可

#### 1.4.1 快速入门
比特币地址以数字1或者3开头。你可以任意的创建新的比特币地址，这些地址都能成功的将资金转到你的钱包。钱包是多个地址和解锁资金密钥的简单集合。每笔交易你都可以使用不同的地址，有利于提高隐私的安全性。



## 第2章 比特币的原理
---

### 2.1 交易、区块、挖矿和区块链
在比特币中，信任是由比特币系统中不同参与者之间交互来达成的一种自然属性。

#### 2.1.1 比特币概述
比特币系统由用户(用户通过密钥控制钱包)、交易(每一笔交易都会被广播到整个比特币网络)和矿工(通过竞争计算生成在每个节点达成共识的区块链，区块链是一个分布式的公共权威账簿，包含了比特币网络发生的所有交易)组成

#### 2.1.2 买咖啡
从千分之一比特币(一毫比特币)到以百万分之一(一聪比特币)，比特币网络可以处理任意小额交易。


### 2.2 比特币交易
简单来说，交易告知全网：比特币的持有者已授权把比特币转账给其他人，而新持有者能够在此授权，转移给比特币所有权链中的其他人，产生另一笔交易来花掉这些比特币。

交易就像复式记账法账簿中的行，简单来说，每一笔交易包含一个或多个"输入"，输入是针对一个毕业币账号的负债。有一个或多个"输出"，被当成信用点数计入到比特币账户中。这些输入和输出的总额不需要相等，相反，当输出累加略少于输入量时，两者的差额就代表了一笔隐含的"矿工费"，这也是将交易放进账簿的矿工所收集到的一笔小额支付。

交易是将钱从交易输入移至输出。输入是指钱币的来源，通常是前一笔交易的输出。输出则是通过关联一个密钥的方式将钱赋予一个新的所有者，目的密钥被称为是安全锁(Encumbrance)。这样就给资金强加了一个要求：有签名才能在以后的交易中赎回资金。

#### 2.2.1 常见的交易形式
最常见的交易形式是从一个地址到另一个地址的简单支付，这种交易也常常包含给支付者的"找零"。一般交易是有一个输入和两个输出；
另一种常见的交易形式是集合多个输入到一个输出的模式，这种类似于现实中零钱兑换为一个大额面钞。
另一种比特币账簿中常见的交易形式是将一个输入分配给多个输出，即多个接收者的交易，类似发工资的情形。


### 2.3 交易的构建
钱包应用设置可以在完全离线时建立交易，只有在执行交易时才需要将交易发送到网络。

#### 2.3.1 获取正确的输入
大多数钱包应用维护者一个含有用钱包自己密钥锁定的"未消费交易输出"小型数据库。
 
完整的客户端好友整个区块链中所有交易的所有为消费输出副本，这是的钱包技能拿这些输出构建交易，也能在收到新交易时很快的验证其输入是否正确，但是会占用太大的硬盘空间。
所以大多数钱包使用轻量级的客户端，只保存自己的未消费输出。如果钱包客户端没有某一未消费输出，它可以通过不同的服务器提供的各种API或完整索引节点的JSON PRC API从比特币网络中拿到这一交易信息

```
查找比特币地址所有的未消费输出
$curl
https://blockchain.info/unspent?active=1Ce19081308hdwahd0921

返回
{
    "unspent_outputs: [
        {
            "tx_hash": "186f932131...123daedjwqdjaodw",
            "tx_index": 104810202,
            "tx_output_n": 0,
            "script": "76adwahoidjwoiajdpwaodkpawdjpowadkwpao",
            "value": 10000000,
            "value_hex: "00989680",
            "confirmations": 0
        }
    ]
}
```

通过这个信息。钱包应用就可以创建新的交易将钱转账到新地址


#### 2.3.2 创建交易输出
交易的输出会被创建成为一个包含这笔数额的脚本的形式，只能被引入这个脚本的一个解答后才能兑换。

#### 2.3.3 将交易放到总账簿中
这个被钱包应用创建的交易大小为258字节，包含了金额未来所需要的全部信息。现在，这个交易必须被传送到比特币网络中以成为分布式账簿(区块链)的一部分。

##### 2.3.3.1 交易的传送
比特币网络是由参与比特币客户端联接几个其他比特币客户端组成的P2P网络。比特币网络的目的是将交易和区块传播给所有参与者

##### 2.3.3.2 如何传播
Alice(输入方)的钱包应用可以发送新的交易给其他任意一个已连接到互联网的比特币客户端，她的钱包不必连着Bob(输出方)的比特币钱包。

任何比特币网络节点(其他客户端)收到一个之前从没有见过的有效交易时，会立即转发给联接到自身的其他节点。因此，这个交易迅速的从P2P网络中传播开来，几秒内就能到达大多数节点。

##### 2.3.3.3 Bob的视角
Alice的交易一般在几秒内到达Bob钱包应用里，Bob钱包应用会立即确认Alice的交易是一个收入支付，因为它包含能用Bob的私钥兑换的输出。Bob的钱包应用也能够独立地用之前未消费输入来确认这个交易是正确构建的，并且由于包含足够的交易费会被下一个区块包含进去。这是Bob就可以以一个很小的风险假定这个交易会很快被加到区块且被确认。


### 2.4 比特币挖矿
这个交易在比特币网络上传播开来，但只有被一个成为挖矿的过程验证且加到一个区块中之后，这个交易才会成为这个共享账簿(区块链)的一部分。

挖矿在比特币系统中起着两个作用：
+ 挖矿在构建区块时会创造新的比特币，和一个中央银行印发新的纸币类似，每个区块创造的比特币数量是固定的，随着时间减少
+ 挖矿创建信任


### 2.5 区块中的挖矿交易记录
网络中产生的一笔交易直到成为整个比特币大账簿(区块链)的一部分时才会被确认有效。平均每10分钟，矿工将会自上一个区块以来发生的所有的交易生成一个新的区块。


### 2.6 消费这笔交易



## 第3章 比特币客户端
---
### 3.1 比特币核心：参考实现
bitcoin.org下载中本聪客户端(satoshi client)。

#### 3.1.1 第一次运行比特币核心

#### 3.1.2 从源码编译比特币核心


### 3.2 通过命令行使用比特币核心的JSON-RPC API接口

#### 3.2.1 获得比特币核心客户端状态的信息
```
$ bitcoin-cli getinfo
{
    "vaersion": 90000,
    "protocolversion": 70002,
    "walletversion": 60000,
    "balance": 0.00000000
    "blocks": 286216,
    "timeoffset": -72,
    "connections": 4,
    "proxy": "",
    "difficulty": 2621404453.06461525,
    "testnet": false,
    "keypoololdest": 1374553827,
    "keypoolsize": 101,
    "paytxfee": 0.000000,
    "errors": ""
}
```

#### 3.2.2 钱包设置及加密
在你向前生成密钥和其他命令之前，你应当先用密码加密钱包。
```
// 密码为"foo"
$ bitcoin-cli encryptwallet foo
```

想要解锁钱包，要使用``walletpassphrase``命令
```
// 360: 多久钱包会被再次自动锁定的秒数
$ bitcoin-cli walletpassphrase foo 360
```

#### 3.2.3 钱包备份、纯文本导出及恢复
```
// 备份钱包
$ bitcoin-cli backupwallet wallet.backup
// 重新加载备份文件
$ bitcoin-cli importwallet wallet.backup
// 将钱包转储为可读的文本文件
$ bitcoin-cli dumpwallet wallet.txt
```

#### 3.2.4 钱包地址及接收交易
```
// 获取比特币客户端维护的地址池中的一个地址，可用作公开接收地址或者零钱地址
$ bitcoin-cli getnewaddress
1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL
```
现在可以使用这个地址从一个外币钱包向我们的bitcoind钱包发送一笔比特币
我们可以询问bitcoind客户端次地址已经收到的比特币的数额，以及指定该数额要被加到余额中所需要的确认数
```
// 需要0个确认，意味着从另一个比特币钱包发送到本钱包后，不需要确认，数秒后本钱包即可看到比特币
$ bitcoin-cli getreceivedbyaddress
1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL 0
0.05000000
```

整个钱包接收到的交易可以用``listtransactions``来展示
```
$ bitcoin-cli listtransactions
[
  {
     "account" : "",
     "address":"1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL",
     "category" : "receive",
     "amount" : 0.05000000,
     "confirmations" : 0,
     "txid" :
"9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309ac
bae2c14ae3",
     "time" : 1392660908,
     "timereceived" : 1392660908
  }
]
```

可以使用``getaddressesbyaccount``来列出整个钱包的所有地址
```
$ bitcoin-cli getaddressesbyaccount ""
[
    "1LQoTPYy1TyERbNV4zZbhEmgyfAipC6eqL",
    "17vrg8uwMQUibkvS2ECRX4zpcVJ78iFaZS",
    "1FvRHWhHBBZA8cGRRsGiAeqEzUmjJkJQWR",
    "1NVJK3JsL41BF1KyxrUyJW5XHjunjfp2jz",
    "14MZqqzCxjc99M5ipsQSRfieT7qPZcM7Df",
    "1BhrGvtKFjTAhGdPGbrEwP3xvFjkJBuFCa",
    "15nem8CX91XtQE8B1Hdv97jE8X44H3DQMT",
    "1Q3q6taTsUiv3mMemEuQQJ9sGLEGaSjo81",
    "1HoSiTg8sb16oE6SrmazQEwcGEv8obv9ns",
    "13fE8BGhBvnoy68yZKuWJ2hheYKovSDjqM",
    "1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL",
    "1KHUmVfCJteJ21LmRXHSpPoe23rXKifAb2",
    "1LqJZz1D9yHxG4cLkdujnqG5jNNGmPeAMD"
]
```

#### 3.2.5 探索及解码交易
我们将使用``gettransaction``命令探索前面列出的入账交易。我们使用``gettransaction``通过交易哈希值获取一笔交易，交易哈希值出现在前面的txid条目
```
$ bitcoin-cli gettransaction
9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3
{
    "amount" : 0.05000000,
    "confirmations" : 0,
    "txid":"9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3",
    "time" : 1392660908,
    "timereceived" : 1392660908,
    "details" : [
    {
        "account" : "",
        "address":"1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL",
        "category" : "receive",
        "amount" : 0.05000000
    }]
}

```
交易ID在交易确认之前并不权威。区块链中找不到交易哈希值并不意味着此笔交易没有进行。这被称作"交易延展性"，因为交易哈希值在区块确认之前是可以更改的。在确认txid之后才是不可变的而且权威的。

若要得到整个交易代码并且将之解码，使用两个命令:``getrawtransaction``和``decoderawtransaction``。``getrawtransaction``把交易哈希值txid当作一个参数，并且把整个交易以一个原始的十六进制字符串的形式返回，而这也正是交易在比特币网络上存在的心事
```
$ bitcoin-cli getrawtransaction
9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae
2c14ae30100000001d717279515f88e2f56ce4e8a31e2ae3e9f00ba1d
0add648e80c480ea22e0c7d3000000008b483045022100a4ebbeec832
25dedead659bbde7da3d026c8b8e12e61a2df0dd0758e227383b30220
3301768ef878007e9ef7c304f70ffaf1f2c975b192d34c5b9b2ac1bd1
93dfba2014104793ac8a58ea751f9710e39aad2e296cc14daa44fa592
48be58ede65e4c4b884ac5b5b6dede05ba84727e34c8fd3ee1d6929d7
a44b6e111d41cc79e05dbfe5ceaffffffff02404b4c00000000001976
a91407bdb518fa2e6089fd810235cf1100c9c13d1fd288ac1f3129060
00000001976a914107b7086b31518935c8d28703d66d09b3623134388
ac00000000
```

一旦我们接收到的交易以记录在区块中的方式被确认，``gettransaction``命令将返回附加信息，显示包含交易的区块的哈希值(标识符)，包括``blockindex``, ``blocktime``, ``blockhash``等。

#### 3.2.6 探索区块
既然知道了我们的交易在哪个区块中，我们可以使用``getblock``命令，并把区块哈希值作为参数来查询对应的区块
```
$ bitcoin-cli getblock 000000000000000051d2e759c63a26e247f185ecb7926ed7a6624b↵
c31c2a717b true
{
   "hash" : "000000000000000051d2e759c63a26e247f185ecb7926ed7a6624bc31c2a717b",
   "confirmations" : 2,
   "size" : 248758,
   "height" : 286384,
   "version" : 2,
   "merkleroot" : "9891747e37903016c3b77c7a0ef10acf467c530de52d84735bd55538719f9916",
   "tx" : [
       "46e130ab3c67d31d2b2c7f8fbc1ca71604a72e6bc504c8a35f777286
       c6d89bf0",
       "2d5625725b66d6c1da88b80b41e8c07dc5179ae2553361c96b14bcf1
       ce2c3868",
       "923392fc41904894f32d7c127059bed27dbb3cfd550d87b9a2dc0382
       4f249c80",
       "f983739510a0f75837a82bfd9c96cd72090b15fa3928efb9cce95f68
       84203214",
       "190e1b010d5a53161aa0733b953eb29ef1074070658aaa656f933ded
       1a177952",
       "ee791ec8161440262f6e9144d5702f0057cef7e5767bc043879b7c2f
       f3ff5277",
       "4c45449ff56582664abfadeb1907756d9bc90601d32387d9cfd4f1ef
       813b46be",
       "3b031ed886c6d5220b3e3a28e3261727f3b4f0b29de5f93bc2de3e97
       938a8a53",
       "14b533283751e34a8065952fd1cd2c954e3d37aaa69d4b183ac64834
       81e5497d",
       "57b28365adaff61aaf60462e917a7cc9931904258127685c18f136ee
       aebd5d35",
       "8c0cc19fff6b66980f90af39bee20294bc745baf32cd83199aa83a1f
       0cd6ca51",
       "1b408640d54a1409d66ddaf3915a9dc2e8a6227439e8d91d2f74e704
       ba1cdae2",
       "0568f4fad1fdeff4dc70b106b0f0ec7827642c05fe5d2295b9deba4f
       5c5f5168",
       "9194bfe5756c7ec04743341a3605da285752685b9c7eebb594c6ed9e
       c9145f86",
       "765038fc1d444c5d5db9163ba1cc74bba2b4f87dd87985342813bd24
       021b6faf",
       "bff1caa9c20fa4eef33877765ee0a7d599fd1962417871ca63a24864
       76637136",
       "d76aa89083f56fcce4d5bf7fcf20c0406abdac0375a2d3c62007f64a
       a80bed74",
       "e57a4c70f91c8d9ba0ff0a55987ea578affb92daaa59c76820125f31
       a9584dfc",
       "9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acba
       e2c14ae3",
       #[... many more transactions ...]
   ],
   "time" : 1392660808,
   "nonce" : 3888130470,
   "bits" : "19015f53",
   "difficulty" : 3129573174.52228737,
   "chainwork" : "000000000000000000000000000000000000000000001931d1658fc04879e466",
   "previousblockhash" : "0000000000000000177e61d5f6ba6b9450e0dade9f39c257b4d48b4941ac77e7",
   "nextblockhash" :"0000000000000001239d2c3bf7f4c68a4ca673e434702a57da8fe0d829a92eb6"
}
```
这个区块包含367条交易，``height``表明这就是整个区块链中的第286384个区块。同样也可以通过``getblockhash``通过区块高度来检索一个区块，需要区块高度作为参数，并且返回那个区块的区块哈希值
```
$ bitcoin-cli getblockhash 0000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
```

#### 3.2.7 基于UTXO(未话费的交易输出)的建立、签名与提交
比特币的交易是基于花费"输出"上的，即上一笔交易的支出，整个交易在地址之间转移所有权。我们的钱包现在收到了向我们发来的钱(输出)，一旦确定之后，钱就归属于我们了。

首先，我们使用``listunspent``查看我们钱包中所有剩余的从之前交易中已确认的支出
```
$ bitcoin-cli listunspent
[
    {
       "txid" :
       "9ca8f969bd3ef5ec2a8685660fdbf7a8bd365524c2e1fc66c309acbae2c14ae3",
       "vout" : 0,
       "address" : "1hvzSofGwT8cjb8JU7nBsCSfEVQX5u9CL",
       "account" : "",
       "scriptPubKey" : "76a91407bdb518fa2e6089fd810235cf1100c9c13d1fd288ac",
       "amount" : 0.05000000,
       "confirmations" : 7
    }
]
```


## 第4章 密钥、地址、钱包
---

### 4.1 简介
比特币的所有权是通过数字密钥、比特币地址和数字签名来确立的。数字密钥实际上并不是存储在网络中，而是由用户生成并存储在一个文件或简单的数据库中，称为钱包。
每笔比特币交易都需要一个有效的签名才会被存储在区块链中。只有有效的数字密钥才能生成有效的数字签名，因此拥有比特币的密钥副本就拥有了该账户的比特币控制权。
密钥是成对出现的，由一个私钥和一个公钥组成。公钥就像银行的账号，而私钥就相当于控制账户的PIN码或支票的签名。比特币用户很少直接看见数字密钥。

在比特币交易的支付环节，收件人的公钥是通过其数字指纹表示的，成为比特币地址。一般情况下，比特币地址由一个公钥生成并对应于这个公钥。

#### 4.1.1 公钥加密和加密货币
比特币正是使用椭圆曲线乘法作为其公钥加密的基础算法。在比特币系统中，我们用公钥加密创建一个密钥对，用于控制比特币获取。秘钥包括一个私钥，和由其衍生出的唯一公钥。公钥用于接收比特币，而私钥用于比特币支付时的交易签名

支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名（每次交易的签名都不同，但均从一个私钥生成），比特币网络中的所有人都可以通过所提交的公钥和签名进行校验，确定该交易是否有效。
公钥可以由私钥计算得到，所以一般只存储私钥即可。

#### 4.1.2 私钥和公钥
私钥是一个数字，一般随机选出，使用椭圆曲线乘法，产生一个公钥，有了公钥，就可以使用一个单向加密哈希函数生产比特币地址。


### 4.4 比特币钱包
钱包是私钥的容器，通常通过有序文件或者简单数据库实现。

非确定性钱包 & 确定性钱包 & 分层确定性钱包



## 第5章 交易
---

### 5.2 比特币交易的生命周期
一笔比特币交易的生命周期诞生之后，会被一个或者多个签名加密，这些签名标志着对该交易只想比特币资金的使用许可。接下来，比特币交易会被广播到比特币网络中，在网络中，每一个节点验证、并将交易在网络中进行广播，
直到这笔交易被网络中绝大多数节点接收。最终，比特币交易被一个挖矿节点验证，并被添加到区块链上一个记录着许多比特币交易的区块中。

### 5.3 交易结构
一笔比特币交易是一个含有输入值和输出值的数据结构，比特币交易的输入值和输出值与账号或者身份信息无关，只有拥有者或者知晓其中信息的人可以解锁

### 5.4 交易的输出和输入

比特币交易的基本单位是未经使用的一个交易输出，简称UTXO。实际上，一个用户的比特币会被当做UTXO分散到数百个交易和数百个区块中，实际上也不存在存储比特币地址或账户余额的地点，只有被所有者锁住的、分散的UTXO。

对于输出和输入链来说，有一个例外，它是一种特殊的交易类型，称为coinbase交易。这是每个区块中的首个交易，这种交易存在的原因是作为对挖矿的奖励而产生的全新的可用于支付的比特币给赢家旷工。这也就是比特币可以在挖矿的过程中被创造出来的原因。

交易输出把用聪表示的一定量的比特币，和特定的定义了支付输出所必须被满足的条件的障碍，或者叫做锁定脚本，关联到了一起。大多数情况下，锁定脚本会把输出锁定在一个特定的比特币地址上，从而把一定数量的比特币转移到新的所有者上。

对于交易输入，简单来说就是指向UTXO的指针。它们只想特定的UTXO，并被交易哈希和在区块链中记录UTXO的序列号作为参考。若想支付UTXO，一个交易的输入也需要包含一个解锁脚本，用来满足UTXO的支付条件，解锁脚本通常是一个签名，用来证明对于该锁定脚本中比特币地址的所有权。

大多数交易包含交易费，这是为了网络安全方面给比特币旷工的一种补偿。交易费基于交易的尺寸，用千字节表示，而不是交易的金额。

### 5.5 交易链条和孤立交易
当一个交易被传到整个网络时，并不总是按照顺序到达目的地。如果子交易先于父交易到达，节点会将该子交易放入一个临时池，并等待接受它的父交易。与此同时广播这个子交易给其他节点。

### 5.6 比特币交易脚本和脚本语言
比特币交易验证引擎依赖于两类脚本来验证比特币：**锁定脚本**和**解锁脚本**

**解锁脚本**              **锁定脚本**
<sig><Pubk> DUP HASH160 <PubHash> EQUALVERIFY CHECKSIG

锁定脚本是一个放在输出值上的障碍，明确了今后话费这笔输出的条件。锁定脚本往往含有一个公钥（即比特币地址）

解锁脚本是一个解决或者满足被锁定脚本在一个输出上设定的花费条件的脚本，同时它将允许输出被消费，解锁脚本是每一笔比特币交易输出的一部分，而且往往含有一个被比特币钱包（通过用户的私钥）生成的数字签名。也叫做ScriptSig


### 5.7 标准交易
开发者对可以经由客户端进行操作的比特币脚本类型设置了一些限制，被编译为一个Standard()函数，目前定义了五种标准：
P2PKH, P2PK, MS, P2SH, OP_Return

和P2PHK相比，P2PK模式更为简单。与P2PKH模式含有公钥哈希模式不同，在P2PK脚本模式中，公钥本身已经存储在锁定脚本中，而且代码长度也更短。锁定脚本仅仅是 OP_CHECKSIG


##### 5.7.3 多重签名
M...N OP_CHECKMULTISIG

#### 5.7.4 数据输出
在0.9版本的比特币核心客户端，采用OP_Return操作符允许开发者在交易输出上增加40字节的非交易数据，然后，与伪交易型的UTXO不同，OP_Return创造了一种明确的可复查的非交易型输出，此类数据无需存储于UTXO集。

#### 5.7.5 P2SH
P2SH是的复杂脚本的运用能与直接向比特币地址支付一样简单。
P2SH的优点：
+ 在交易输出时，复杂脚本由剪短电子指纹取代，使交易代码变短
+ 极爱本能被编译为地址，支付指令的发出者和钱包不需要复杂工序
+ P2SH将构建脚本的重担转移至接收方，而非发送方
+ P2SH将长脚本数据存储的负担从输出方（存储于UTXO集，影响内存）转移至输入方（仅存储于区块链）
+ P2SH将长脚本数据存储的重担从当前（支付时）转移至未来（花费时）
+ P2SH将长脚本的交易费成本从发送方转移至接收方，接收方在使用该笔资金时必须含有赎回脚本



## 第6章 比特币网络
---

每个比特币节点都是又路由、区块链数据库、挖矿、钱包服务的功能集合，一个全节点包含所有四个功能

新的网络节点启动后，必须至少发现一个网络中存在的节点并建立连接，节点通常采用TCP协议，端口8333与已知的对等节点建立连接。

因为节点可以随时加入和离开，通讯路径是不可靠的，因此节点必须进行两项工作：在失去已有连接时发现新节点；在其他节点启动时为其提供帮助。

一个节点没有必要连接到大量的对等节点，浪费网络资源。在启动后，节点会记住它最近成功连接的对等节点，重启后可以迅速恢复进入网络。

对于检查某个区块中的交易：
+ 全节点：把从该区块一直回溯到创世区块的这些区块全部链接起来，建立一个完整的UTXO数据库，通过确认该UTXO是否还未被支付来验证交易的有效性
+ SPV节点：会在该交易信息和它所在区块之间用merkle路径建立一条链接，然后SPV节点一直等待，知道其后6个区块堆叠在该交易区块智商，并通过交易的深度是在后6块之下来验证交易的有效性，SPV可以验证一个交易的存在性，但不能验证一个交易不存在。

在SPV节点里，使用Bloom过滤器用来向对等节点发送交易信息查询请求，同时交易地址不会被暴露。


比特币网络中几乎每个节点都会维护一份未确认的临时列表，成为内存池或交易池，节点们利用这个池来追踪那些被网络所知晓，但还未被区块链所包含的交易。
有些节点的实现还维护着一个单独的孤立交易池，如果一个交易的输入与某未知的交易有归案，如与缺失的父交易相关，该孤立交易就会被暂时储存在孤立交易池中直到父交易的信息到达。
有些比特币客户端的实现还维护者一个UTXO数据库，也称UTXO池，是区块链中所有未支付交易输出的集合。


## 第7章 区块链
---

### 7.2 区块结构
区块是一种被包含在区块链里的聚合了交易信息的容器数据结构，它由一个包含元数据的区块头和紧跟其后的区块主体（一长串交易）组成。
区块头80字节，平均每个交易至少是250字节，而且每个区块至少包含500个交易，因此一个包含所有交易的完整区块的大小是区块头的100倍以上

### 7.3 区块头
+ 引用父区块哈希值的数据
+ 难度、时间戳和nonce（工作量证明算法的计数器），与挖矿竞争相关
+ merkle树根

区块的主标识符就是它的加密哈希值，一个通过SHA256对区块头进行2次哈希计算得到的数字指纹，产生的32字节哈希值就被成为区块哈希值。
实际上，区块哈希值并不包含在区块的数据结构里

区块的高度也可以作为识别区块的方式，第一个区块的高度为0。

### 7.7 Merkle树
区块链中每个区块都包含了产生于该区块的所有交易，且以Merkle树表示。
Merkle树是一种哈希二叉树。用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹，且提供了一种校验区块是否存在某个交易的高效途径。在比特币的Merkle树种两次使用到了SHA256算法，成为double-SHA256

比如4个交易：A、B、C和D
H~A = SHA256（SHA256（交易A）），B、C和D依次计算，然后串联相邻叶子节点再计算哈希：
H~AB= SHA256（SHA256（H~A+ H~B))，类似操作，直到只剩下顶部的一个节点，即Merkle根


## 第8章 挖矿与共识
---

矿工们通过为比特币网络提供算例还换区获得比特币奖励的机会，矿工们验证每笔新的交易并把它们记录在总账簿上，每10分钟，就会有一个新的区块被挖掘出来。

矿工在挖矿过程中会得到两种类型的奖励：创建新区块的新币奖励，以及区块中所含交易的交易费。

挖矿的本质不是奖励本身或者新币的产生，而是一种结算所去中心化的过程，每个结算所对处理的交易进行验证和结算，保护了比特币系统的安全。

比特币的去中心化共识由所有网络节点的4种独立过程相互作用而产生：
+ 每个节点依据综合标准对每个交易进行独立验证
+ 通过完成工作量证明算法的验算，挖矿节点将交易记录独立打包进新区块
+ 每个节点独立的对新区块进行校验并组装进区块链
+ 每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链

每一个节点在校验每一笔交易时，都需要对照一个长长的标准列表，在收到交易后，每个一个节点都会在全网广播前对这些交易进行校验，并以接收时的顺序，为有效的新交易建立一个内存池（交易池）。

验证交易后，比特币节点会将这些交易添加到自己的内存池中，内存池也称作交易池。

矿工节点需要为内存池中每笔交易分配一个优先级，并选择较高优先级的交易记录来构建候选区块。交易的优先级是由交易输入所花费的UTXO的"块龄"决定，交易输入值高，"块龄"大的交易币那些新的、输入值小的交易拥有更高的优先级
如果区块中有足够空间，高优先级的交易行为将不需要矿工费。

```
// Value of input: 以聪为单位的比特币
// Input Age: 自该UTXO被记录到区块链位置所经历过的区块数，即这个UTXO在区块链中的深度
// Transaction: 字节为单位的交易大小
// 高优先级门槛：1个比特币，144个区块，交易大小250字节
优先级 = Sum(Value of input * Input Age) / Transaction Size
```

区块中用来存储交易的前50K字节是用来保留给较高优先级交易的，这种机制使得高优先级交易即便是无矿工费，也可以优先被处理。
然后再按照"每千字节矿工费"排序，优先选择矿工费高的交易来填充剩下的区块，区块大小上限为MAX_BLOCK_SIZE，如果此时仍有剩余，有些矿工会忽略这些交易，有些会竭尽全力把不含矿工费的交易整合到区块

在区块被填满以后，内存池中剩余交易会成为下一个区块的候选交易，由于这些交易的UTXO值会不断加大，因此这个交易的优先级也不断增大，有可能会直接满足高优先级的门槛而被免费打包到区块


### 8.5.2 创币交易
区块中的第一笔交易是特殊交易，成为创币交易或者coinbase交易。
与常规交易不同，创币交易没有输入，不消耗UTXO，有一个输出，支付到这个矿工的比特币地址。

### 8.5.3 Coinbase奖励与矿工费
为了构造创币交易，挖矿节点需要计算矿工费的总额：
```
Total Fees = Sum(Inputs) - Sum(Outputs)
```
新区块的奖励额是基于区块高度的，以每个区块50比特币开始，每产生210000区块减半一次。

### 8.5.5 Coinbase数据
创币交易不包含"解锁脚本"（scriptSig），这个字段被coinbase数据代替，长度2~100字节，除了开始的几个字节，矿工可以任何使用coinbase的其他部分，随意填充任何数据


### 8.6 构造区块头
为了构造区块头，挖矿节点需要填充六个字段
+ 4字节的 版本号
+ 32字节的 前区块哈希
+ 32字节的 Merkle根
+ 4字节的 时间戳
+ 4字节的 难度目标，定义了所需满足工作量证明的难度，以"尾数-指数"的格式编码存储，首字节表示指数，后3字节表示尾数
+ 4字节的 Nonce，用于工作了证明算法的计数器

区块头完成全部的字段填充后，挖矿就可以开始了。挖矿的目标是找到一个使区块头哈希值小于难度目标的nonce，挖矿节点通常需要尝试数十亿次甚至更多，直到找到一个满足条件的nonce


### 8.7 构建区块
比特币挖矿过程使用的就是SHA256函数。
简单来说，挖矿就是重复计算区块头的哈希值，不断修改该参数，直到与哈希值匹配的一个过程，哈希函数的结果无法提前得知，也没有得到一个特定哈希值的模式。
简单来说，挖矿就是重复计算区块头的哈希值，不断修改该参数，直到与哈希值匹配的一个过程，哈希函数的结果无法提前得知，也没有得到一个特定哈希值的模式。

比特币的工作量证明过程如下：
矿工用一些交易构建一个候选区块，接下来，矿工计算这个区块头的哈希值，看是否小于当前的目标值，如果不小于，矿工就会修改这个nonce（一般+1），然后再计算。直到找到一个合适的nonce使得区块头哈希值足够小

### 8.7.2 难度表示
```
target = coefficient * 2 ^(8*(exponet - 3))
```

### 8.7.3 难度目标与难度调整
难度是一个动态的参数，会定期调整以达到每10分钟一个新区块的目标。
在一个完全去中心化的网络中，难度调整是在每个完整节点中独立自动发生的，每2016个区块中所有节点都会调整难度，难度的调整公式是由最新2016个区块花费时长与20160分钟比较得出的。
```
new difficulty = old difficultyy * (actual time of last 2016 blocks / 20160 munites)
```
可见的是，目标难度与交易的数量和金钱无关。


### 8.8 成功构建区块
在得到一个满足目标的nonce之后，挖矿节点会立刻将这个区块发送给它相邻的所有节点，这些节点在接收并验证这个区块之后，也会继续传播此区块。当挖矿节点接收到并验证了这个新区块之后，它们会放弃之前构建这个相同高度区块的计算，并立即开始下一个区块的工作。

### 8.9 校验新区块
当每一个节点将新区块转发到其他节点之前，会进行一系列的测试区验证它。每一个节点对每一个新区块独立校验，确保了矿工无法欺诈。

#### 8.10.1 区块链分叉
区块链不同副本之间不能总是保持一致，区块有可能在不同时间到达不同节点。解决办法是：
每一个节点总是选择并尝试延长代表累积了最大工作量证明的区块链，也就是最长或者最大累计难度的链。节点通过将记录在每个区块中的难度加起来，得到建立这个链所付出的工作量证明的总量，只要是所有节点都选择最长累计难度的链，
整个比特币网络最终会收敛到一致的状态。


## 第9章 竞争币、竞争块链和应用程序
---

### 9.4.3 以太坊
以太坊是一种图灵完备的平台，基于区块链账簿，用于合约的处理和执行。它不是比特币的一个克隆，而是完全独立的一种设计和实现。
以太坊内置一种叫做ether的货币，该货币是付合约执行费用所必须的。以太坊区块链记录的东西叫做合约，也就是一种低级二进制码，也是一种图灵完备语言。
被智商，合约其实是运行在以太坊系统中的各个节点上的程序，这些程序可以存储数据、支付以及收取、存储ether以及执行计算行为。



